<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üî¨Laberinto de F√≠sica ‚öõÔ∏è v3</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* ===========================================
            VARIABLES CSS - MANTENIENDO LO QUE FUNCIONABA
            =========================================== */
        :root {
            --background: 240 10% 3.9%;
            --foreground: 0 0% 98%;
            --card: 240 10% 3.9%;
            --card-foreground: 0 0% 98%;
            --primary: 250 47% 60%; /* Violeta primario */
            --primary-foreground: 0 0% 98%;
            --secondary: 240 3.7% 15.9%; /* Gris oscuro secundario */
            --secondary-foreground: 0 0% 98%;
            --muted: 240 3.7% 15.9%;
            --muted-foreground: 240 5% 64.9%; /* Gris claro texto */
            --accent: 48 96% 68%; /* Amarillo acento */
            --accent-foreground: 240 5.9% 10%;
            --destructive: 0 62.8% 30.6%; /* Rojo destructivo */
            --destructive-foreground: 0 0% 98%;
            --wall-color: 250 47% 40%; /* Color pared */
            --player-color: 48 96% 68%; /* Color jugador (amarillo) */
            --ghost-color: 199 89% 64%; /* Color fantasma base */
            --power-pellet-color: 30 100% 50%; /* Naranja para power pellet */
            --help-button-color: 210 80% 60%; /* Azul claro para ayuda */
            --help-button-hover: 210 80% 50%;
            --question-title-color: var(--accent); /* Amarillo para t√≠tulo pregunta */
            --option-hover-bg: hsl(var(--muted) / 0.8);
            --option-selected-bg: hsl(var(--primary) / 0.7);
            --option-selected-border: hsl(var(--accent));
        }

        /* ===========================================
            RESET Y ESTILOS BASE
            =========================================== */
        * { 
            box-sizing: border-box; 
            margin: 0; 
            padding: 0; 
        }

        body {
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            padding-bottom: 60px; /* Espacio para footer */
        }

        /* ===========================================
            BOTONES GLOBALES - MEJORANDO LOS ORIGINALES
            =========================================== */
        #globalControlButtons {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 10000;
            display: flex;
            gap: 8px;
        }

        .global-btn {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: background-color 0.2s, transform 0.1s ease;
            background-color: hsl(var(--secondary));
            color: hsl(var(--secondary-foreground));
            border: 1px solid hsl(var(--muted-foreground));
        }

        .global-btn:hover { 
            background-color: hsl(var(--muted)); 
        }
        .global-btn:active { 
            transform: scale(0.95); 
        }

        /* ===========================================
            ESTILOS GENERALES DE BOTONES - MEJORADOS
            =========================================== */
        .button {
            display: inline-flex; 
            align-items: center; 
            justify-content: center;
            border-radius: 0.5rem; 
            font-weight: 500; 
            padding: 0.6rem 1.2rem; /* M√°s padding */
            transition: background-color 0.2s, transform 0.1s ease; 
            cursor: pointer; 
            border: none;
        }

        .button-primary { 
            background-color: hsl(var(--primary)); 
            color: hsl(var(--primary-foreground)); 
        }
        .button-primary:hover { 
            background-color: hsl(var(--primary) / 0.9); 
        }

        .button-secondary { 
            background-color: hsl(var(--secondary)); 
            color: hsl(var(--secondary-foreground)); 
            border: 1px solid hsl(var(--muted-foreground));
        }
        .button-secondary:hover { 
            background-color: hsl(var(--muted)); 
        }

        .button-accent { 
            background-color: hsl(var(--accent)); 
            color: hsl(var(--accent-foreground)); 
        }
        .button-accent:hover { 
            background-color: hsl(var(--accent) / 0.9); 
        }

        .button-help { 
            background-color: var(--help-button-color); 
            color: hsl(var(--primary-foreground)); 
        }
        .button-help:hover { 
            background-color: var(--help-button-hover); 
        }

        .button:active { 
            transform: scale(0.97); 
        }

        /* ===========================================
            LAYOUT PRINCIPAL
            =========================================== */
        .container { 
            max-width: 1000px; 
            width: 100%; 
            padding: 1rem; 
        }

        .card {
            background-color: hsl(var(--card)); 
            color: hsl(var(--card-foreground));
            border-radius: 0.75rem; 
            padding: 2rem; 
            box-shadow: 0 6px 12px rgba(0,0,0,0.2); 
            text-align: center;
        }

        .header { 
            text-align: center; 
            margin-bottom: 1.5rem; 
        }
        .header h1 { 
            font-size: 2.2rem; 
            color: hsl(var(--primary)); 
            margin-bottom: 0.5rem; 
        }

        /* ===========================================
            SELECTOR DE NIVEL - MANTENIENDO FUNCIONAMIENTO
            =========================================== */
        .level-selector { 
            text-align: center; 
            max-width: 500px; 
            margin: 0 auto; 
        }
        .level-selector h2 { 
            margin-bottom: 1rem; 
            font-size: 1.5rem; 
        }
        .level-selector p { 
            margin-bottom: 1.5rem; 
            color: hsl(var(--muted-foreground));
        }

        .level-tabs { 
            display: grid; 
            grid-template-columns: repeat(4, 1fr); 
            gap: 0.75rem; 
            margin: 1rem 0; 
        }

        .level-tab {
            background-color: hsl(var(--secondary)); 
            color: hsl(var(--secondary-foreground)); 
            border: none;
            padding: 0.75rem; 
            border-radius: 0.5rem; 
            cursor: pointer; 
            transition: background-color 0.2s, transform 0.1s ease;
            font-weight: 500;
        }
        .level-tab:hover { 
            background-color: hsl(var(--muted)); 
        }
        .level-tab.active { 
            background-color: hsl(var(--primary)); 
            color: hsl(var(--primary-foreground)); 
        }
        .level-tab:active { 
            transform: scale(0.95); 
        }

        .level-description { 
            font-size: 0.9rem; 
            margin-top: 1rem; 
            color: hsl(var(--muted-foreground)); 
            min-height: 40px; 
        }

        #buttonContainer { 
            display: flex; 
            flex-direction: column; 
            gap: 1rem; 
            margin-top: 1.5rem; 
        }

        /* ===========================================
            UI DEL JUEGO - PRESERVANDO FUNCIONAMIENTO
            =========================================== */
        .game-ui-bar {
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            max-width: 600px; 
            margin: 0 auto 1rem auto;
            gap: 1rem; 
            flex-wrap: wrap;
        }

        .game-stats { 
            display: flex; 
            gap: 1rem; 
            flex-wrap: wrap; 
        }

        .stat-item {
            display: flex; 
            align-items: center; 
            gap: 0.5rem;
            background-color: hsl(var(--secondary) / 0.8); 
            padding: 0.4rem 0.8rem;
            border-radius: 1rem; 
            font-size: 0.9rem; 
            font-weight: 500;
        }

        .stat-item span:first-child { 
            font-size: 1.2rem; 
        }
        #livesValue { 
            color: hsl(var(--destructive)); 
            font-weight: bold; 
        }
        #scoreValue { 
            color: hsl(var(--accent)); 
            font-weight: bold; 
        }
        #questionProgressValue { 
            color: hsl(var(--primary)); 
            font-weight: bold; 
        }

        /* ===========================================
            BARRA DE PROGRESO
            =========================================== */
        .progress-display { 
            display: flex; 
            align-items: center; 
            gap: 0.5rem; 
            max-width: 600px; 
            margin: 0 auto 1rem auto; 
        }
        .progress-display span:first-child { 
            font-size: 0.9rem; 
            font-weight: 500;
        }
        .progress-container { 
            flex-grow: 1; 
            height: 10px; 
            background-color: hsl(var(--secondary)); 
            border-radius: 5px; 
            overflow: hidden; 
        }
        .progress-bar { 
            height: 100%; 
            background-color: hsl(var(--primary)); 
            transition: width 0.3s; 
            border-radius: 5px; 
        }

        /* ===========================================
            LABERINTO - MANTENIENDO ESTILOS FUNCIONALES
            =========================================== */
        .game-maze {
            background-color: hsl(var(--background)); 
            position: relative; 
            margin: 0 auto;
            overflow: hidden; 
            border: 4px solid hsl(var(--wall-color));
            box-shadow: 0 0 20px rgba(139,92,246,0.5); 
            border-radius: 0.5rem;
        }

        #staticContainer, 
        #dynamicContainer { 
            position: absolute; 
            left: 0; 
            top: 0; 
            width: 100%; 
            height: 100%; 
        }

        .wall { 
            background-color: hsl(var(--wall-color)); 
            position: absolute; 
        }

        .fruit, 
        .power-pellet {
            position: absolute; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            animation: pulse 2s infinite ease-in-out;
        }

        .fruit { 
            font-size: var(--fruit-size, 16px); 
        }
        .power-pellet {
            font-size: var(--power-pellet-size, 20px);
            animation-duration: 1s;
            text-shadow: 0 0 8px var(--power-pellet-color);
        }

        @keyframes pulse { 
            0%, 100% { transform: scale(1); } 
            50% { transform: scale(1.15); } 
        }

        /* ===========================================
            JUGADOR (PAC-MAN) - MANTENIENDO FUNCIONAMIENTO
            =========================================== */
        .pacman-player {
            width: var(--player-size, 20px); 
            height: var(--player-size, 20px);
            background-color: hsl(var(--player-color)); 
            border-radius: 50%; 
            position: absolute;
            transition: left 0.1s linear, top 0.1s linear, transform 0.1s linear;
        }

        .pacman-mouth {
            width: 50%; 
            height: 100%; 
            background-color: hsl(var(--background));
            position: absolute; 
            top: 0; 
            right: 0;
            clip-path: polygon(100% 0%, 40% 50%, 100% 100%);
            animation: chomp 0.3s linear infinite;
            transform-origin: left center;
        }

        .pacman-player[data-direction="right"] .pacman-mouth { transform: rotate(0deg); }
        .pacman-player[data-direction="left"] .pacman-mouth { transform: rotate(180deg); }
        .pacman-player[data-direction="up"] .pacman-mouth { transform: rotate(-90deg); }
        .pacman-player[data-direction="down"] .pacman-mouth { transform: rotate(90deg); }
        
        @keyframes chomp {
            0%, 100% { clip-path: polygon(100% 0%, 40% 50%, 100% 100%); }
            50% { clip-path: polygon(100% 40%, 40% 50%, 100% 60%); }
        }

        /* ===========================================
            FANTASMAS - MANTENIENDO FUNCIONAMIENTO
            =========================================== */
        .ghost {
            width: var(--ghost-size, 20px); 
            height: var(--ghost-size, 20px);
            border-radius: 50% 50% 35% 35%; 
            position: absolute;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3); 
            transition: left 0.3s ease, top 0.3s ease;
            display: flex; 
            justify-content: center; 
            align-items: flex-start;
            padding-top: 4px;
        }

        .ghost-eyes { 
            position: relative; 
            display: flex; 
            gap: 4px; 
        }
        .ghost-eye {
            width: 5px; 
            height: 7px; 
            background-color: white; 
            border-radius: 50%;
            position: relative; 
            border: 1px solid black;
        }
        .ghost-pupil {
            width: 2px; 
            height: 3px; 
            background-color: black; 
            border-radius: 50%;
            position: absolute; 
            top: 2px; 
            left: 1.5px;
            transition: transform 0.1s linear;
        }

        .ghost[data-look="right"] .ghost-pupil { transform: translateX(0.5px); }
        .ghost[data-look="left"] .ghost-pupil { transform: translateX(-0.5px); }
        .ghost[data-look="down"] .ghost-pupil { transform: translateY(1px); }
        .ghost[data-look="up"] .ghost-pupil { transform: translateY(-1px); }

        /* ===========================================
            CONTROLES M√ìVILES
            =========================================== */
        .mobile-controls {
            display: grid; 
            grid-template-columns: repeat(3, 1fr); 
            grid-template-rows: repeat(3, 1fr);
            gap: 8px; 
            width: 160px; 
            height: 160px; 
            margin: 20px auto 0;
        }

        .mobile-controls button {
            background-color: hsl(var(--primary)); 
            color: hsl(var(--primary-foreground)); 
            border-radius: 8px;
            border: none; 
            display: flex; 
            align-items: center; 
            justify-content: center;
            transition: transform 0.2s; 
            cursor: pointer; 
            font-size: 1.5rem;
        }
        .mobile-controls button:active { 
            transform: scale(0.95); 
            background-color: hsl(var(--primary) / 0.8); 
        }

        .up { grid-column: 2; grid-row: 1; } 
        .left { grid-column: 1; grid-row: 2; }
        .right { grid-column: 3; grid-row: 2; } 
        .down { grid-column: 2; grid-row: 3; }

        /* ===========================================
            DI√ÅLOGOS - ESTRUCTURA B√ÅSICA
            =========================================== */
        .dialog-overlay {
            position: fixed; 
            top: 0; 
            left: 0; 
            right: 0; 
            bottom: 0; 
            background-color: rgba(0,0,0,0.7);
            display: flex; /* Changed from none to flex for default visibility handling by JS */
            align-items: center; 
            justify-content: center; 
            z-index: 1000; 
            backdrop-filter: blur(4px);
        }

        .dialog-content {
            background-color: hsl(var(--card)); 
            border-radius: 0.75rem; 
            padding: 1.5rem 2rem;
            width: 90%; 
            max-width: 500px; 
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            color: hsl(var(--card-foreground));
        }

        .dialog-header { 
            margin-bottom: 1rem; 
            text-align: center; 
        }
        .dialog-title { 
            font-size: 1.6rem; 
            font-weight: bold; 
            margin-bottom: 0.75rem; 
            color: hsl(var(--primary)); 
        }
        .dialog-description { 
            color: hsl(var(--muted-foreground)); 
            font-size: 0.95rem; 
        }
        .dialog-body { 
            margin-top: 1.5rem; 
        }
        .dialog-footer { 
            display: flex; 
            justify-content: center; 
            margin-top: 1.5rem; 
        }

        /* ===========================================
            NOTIFICACIONES TOAST
            =========================================== */
        .toast-container { 
            position: fixed; 
            bottom: 1rem; 
            right: 1rem; 
            z-index: 1000; 
        }
        .toast {
            background-color: hsl(var(--card)); 
            color: hsl(var(--foreground)); 
            border-radius: 0.5rem;
            padding: 1rem; 
            margin-top: 0.5rem; 
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: opacity 0.3s, transform 0.3s; 
            max-width: 350px; 
            border-left: 4px solid;
            opacity: 0; /* Start hidden for animation */
            transform: translateX(100%); /* Start off-screen for animation */
        }
        .toast-title { 
            font-weight: bold; 
            margin-bottom: 0.25rem; 
        }
        .toast-default { 
            border-left-color: hsl(var(--primary)); 
        }
        .toast-default .toast-title { 
            color: hsl(var(--primary)); 
        }
        .toast-destructive { 
            border-left-color: hsl(var(--destructive)); 
        }
        .toast-destructive .toast-title { 
            color: hsl(var(--destructive)); 
        }
        .toast-success { 
            border-left-color: #2ecc71; 
        }
        .toast-success .toast-title { 
            color: #2ecc71; 
        }

        /* Vulnerable ghost animation */
        .ghost.vulnerable {
            animation: vulnerablePulse 0.5s infinite alternate;
        }
        .ghost.vulnerable-ending {
            animation: vulnerableEndingPulse 0.3s infinite alternate;
        }
        @keyframes vulnerablePulse {
            from { opacity: 1; background-color: #0066FF; }
            to { opacity: 0.7; background-color: #004CBB; }
        }
        @keyframes vulnerableEndingPulse {
            from { background-color: #FF6666; opacity: 1;} /* Reddish blinking */
            to { background-color: #CC0000; opacity: 0.7;}
        }

        /* Option button styling */
        .options-container {
            display: grid;
            grid-template-columns: 1fr; /* Default to 1 column */
            gap: 0.75rem;
        }
        @media (min-width: 480px) { /* 2 columns for wider screens */
            .options-container {
                grid-template-columns: 1fr 1fr;
            }
        }

        .option-btn {
            background-color: hsl(var(--secondary));
            color: hsl(var(--secondary-foreground));
            border: 1px solid hsl(var(--muted-foreground));
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s, transform 0.1s;
            text-align: left;
            font-size: 0.95rem;
        }
        .option-btn:hover {
            background-color: var(--option-hover-bg);
            border-color: hsl(var(--primary));
        }
        .option-btn:active {
            transform: scale(0.98);
        }
        .option-btn.selected { /* Style for selected (but not yet confirmed) option if needed */
            background-color: var(--option-selected-bg);
            border-color: var(--option-selected-border);
            font-weight: bold;
        }

        /* Completion Dialog Stats */
        .completion-stat {
            background-color: hsl(var(--secondary) / 0.5);
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.95rem;
        }
        .completion-stat span:first-child {
            color: hsl(var(--muted-foreground));
        }

        /* ===========================================
            FOOTER
            =========================================== */
        footer {
            text-align: center; 
            padding: 1rem 0; 
            color: hsl(var(--muted-foreground));
            margin-top: 2rem; 
            font-size: 0.85rem;
        }

        /* ===========================================
            MEDIA QUERIES
            =========================================== */
        @media (max-width: 768px) {
            body { 
                padding: 0.5rem; 
                padding-bottom: 50px; 
            }
            .container { 
                padding: 0.5rem; 
            }
            .header h1 { 
                font-size: 1.8rem; 
            }
            .card { 
                padding: 1.5rem; 
            }
            .game-maze { 
                border-width: 2px; 
                box-shadow: 0 0 10px rgba(139,92,246,0.3); 
            }
            .game-ui-bar { 
                justify-content: center; 
            }
            .mobile-controls { 
                width: 180px; 
                height: 180px; 
                gap: 10px; 
            }
            .dialog-content { 
                width: 95%; 
                padding: 1.5rem; 
            }
            .dialog-title { 
                font-size: 1.3rem; 
            }
            #globalControlButtons { 
                flex-direction: column; 
                right: 5px; 
                top: 5px; 
                gap: 5px; 
            }
            .global-btn { 
                padding: 0.4rem 0.8rem; 
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div id="globalControlButtons">
        <button id="globalPauseBtn" class="global-btn">Pausar</button>
        <button id="globalResetBtn" class="global-btn">Reiniciar</button>
    </div>

    <div class="container">
        <header class="header">
            <h1>üî¨Laberinto de F√≠sica ‚öõÔ∏è v3</h1>
        </header>

        <div id="app">
            <div class="level-selector card">
                <h2>Cargando...</h2>
                <p>El juego se est√° inicializando. Si este mensaje persiste, revisa la consola del navegador.</p>
            </div>
        </div>

        <div class="toast-container" id="toastContainer"></div>
        <div id="questionDialog" class="dialog-overlay" style="display: none;">
            </div>
        <div id="completionDialog" class="dialog-overlay" style="display: none;">
            </div>
        <div id="helpDialog" class="dialog-overlay" style="display: none;">
            </div>
    </div>

    <footer>
        Autor: Msc N√©stor Fabio Montoya Palacios
    </footer>

    <script>
        // ===============================================================
        // üî¨ LABERINTO DE F√çSICA v3 - C√ìDIGO COMPLETO Y CORREGIDO
        // ===============================================================
        console.log("üî¨ Laberinto de F√≠sica v3 - Iniciando...");

        // ===============================================================
        // üîä GESTOR DE SONIDOS (REFINADO)
        // ===============================================================
        const soundManager = {
            isInitialized: false, // Flag para indicar si Tone.start() ha sido exitoso y los sonidos est√°n listos.
            sounds: {},
            masterVolume: -6, // Volumen maestro en dB

            /**
             * Inicializa el AudioContext de Tone.js y carga los sonidos.
             * DEBE ser llamado como resultado de una interacci√≥n del usuario para cumplir con las pol√≠ticas de autoplay.
             */
            async init() {
                // Si el contexto ya est√° corriendo y el manager ya fue inicializado, no hacer nada.
                if (Tone.context.state === 'running' && this.isInitialized) {
                    return;
                }

                // Si el contexto ya est√° corriendo pero el manager no (ej. recarga de p√°gina con contexto persistente),
                // solo cargar sonidos.
                if (Tone.context.state === 'running' && !this.isInitialized) {
                    console.log("üîä AudioContext ya estaba corriendo. Cargando sonidos...");
                    Tone.Destination.volume.value = this.masterVolume;
                    if (Tone.Transport.state !== "started") Tone.Transport.start();
                    this.loadSounds();
                    this.isInitialized = true;
                    console.log("üîä SoundManager listo (contexto preexistente).");
                    return;
                }

                // Si el contexto NO est√° en ejecuci√≥n, intentar iniciarlo.
                // Esto es crucial y debe ser invocado por un gesto del usuario.
                try {
                    console.log("üîä Intentando iniciar AudioContext v√≠a Tone.start()...");
                    await Tone.start(); 
                    console.log(`üîä Estado de AudioContext despu√©s de Tone.start(): ${Tone.context.state}`);

                    if (Tone.context.state === 'running') {
                        Tone.Destination.volume.value = this.masterVolume;
                        if (Tone.Transport.state !== "started") Tone.Transport.start(); 
                        this.loadSounds();
                        this.isInitialized = true; 
                        console.log("üîä SoundManager inicializado exitosamente (AudioContext y Transporte iniciados).");
                    } else {
                        console.warn(`üîä AudioContext no se inici√≥ correctamente despu√©s de Tone.start(). Estado: ${Tone.context.state}. Los sonidos no funcionar√°n hasta nueva interacci√≥n del usuario.`);
                        this.isInitialized = false; 
                    }
                } catch (e) {
                    console.error("Error durante Tone.start() o carga de sonidos:", e);
                    this.isInitialized = false;
                }
            },

            loadSounds() {
                // Prevenir recarga si ya est√°n definidos.
                if (Object.keys(this.sounds).length > 0) {
                    console.log("üîä Sonidos ya definidos, no se recargar√°n.");
                    return;
                }
                console.log("üîä Cargando definiciones de sonidos...");

                // Definici√≥n de sintetizadores para cada efecto de sonido.
                this.sounds.chomp = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.005, decay: 0.05, sustain: 0, release: 0.1 }, volume: -12 }).toDestination();
                this.sounds.fruitCollect = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 }, volume: -10 }).toDestination();
                this.sounds.powerPelletCollect = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.3 }, volume: -8 }).toDestination();
                
                this.sounds.powerPelletLoopSynth = new Tone.Synth({
                    oscillator: { type: "pulse", width: 0.6 },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 },
                    volume: -14 
                }).toDestination();

                // Limpiar loop anterior si existe antes de crear uno nuevo.
                if (this.sounds.powerPelletActiveLoop && typeof this.sounds.powerPelletActiveLoop.dispose === 'function') {
                    this.sounds.powerPelletActiveLoop.dispose();
                }
                this.sounds.powerPelletActiveLoop = new Tone.Loop(time => {
                    if (gameState.powerPelletActive && this.sounds.powerPelletLoopSynth) { 
                        this.sounds.powerPelletLoopSynth.triggerAttackRelease("A4", "32n", time);
                    }
                }, "8n");

                this.sounds.ghostEaten = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.05, decay: 0.4, sustain: 0, release: 0.2 }, volume: -5 }).toDestination();
                this.sounds.playerCaught = new Tone.NoiseSynth({ noise: { type: "pink" }, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.1 }, volume: -5 }).toDestination();
                this.sounds.correctAnswer = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 }, volume: -10 }).toDestination();
                this.sounds.incorrectAnswer = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.2 }, volume: -12 }).toDestination();
                this.sounds.gameStart = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.2, release: 0.5 }, volume: -8 }).toDestination();
                this.sounds.gameWin = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.1, decay: 1.0, sustain: 0.5, release: 1.0 }, volume: -7 }).toDestination();
                this.sounds.gameOver = new Tone.Synth({ oscillator: { type: "square" }, envelope: { attack: 0.1, decay: 1.2, sustain: 0, release: 0.5 }, volume: -9 }).toDestination();
                this.sounds.buttonClick = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }, volume: -14 }).toDestination();
                
                console.log("üîä Sonidos cargados/definidos.");
            },

            play(soundName, note = "C4", duration = "8n") {
                // Intenta inicializar si es necesario (ej. si el usuario interactu√≥ pero init a√∫n no se llam√≥ o fall√≥)
                // Esto es un fallback, lo ideal es que init() ya haya sido llamado exitosamente por una interacci√≥n.
                if (!this.isInitialized && Tone.context.state === 'suspended') {
                     console.log("üîä Contexto suspendido al intentar reproducir. Intentando init() por si acaso...");
                     this.init().then(() => { // Intenta init y luego reproduce si tiene √©xito
                         if (this.isInitialized && this.sounds[soundName] && Tone.context.state === 'running') {
                             this._executePlay(soundName, note, duration);
                         } else {
                            console.warn(`üîä Sonido "${soundName}" no se pudo reproducir despu√©s del intento de init tard√≠o.`);
                         }
                     });
                     return;
                }
                
                if (!this.isInitialized || !this.sounds[soundName] || Tone.context.state !== 'running') {
                    console.warn(`Sonido "${soundName}" no se puede reproducir. SoundManager Inicializado: ${this.isInitialized}, AudioContext: ${Tone.context.state}, Sonido existe: ${!!this.sounds[soundName]}`);
                    return;
                }
                this._executePlay(soundName, note, duration);
            },

            _executePlay(soundName, note, duration) {
                try {
                    if (soundName === 'playerCaught' && this.sounds.playerCaught instanceof Tone.NoiseSynth) {
                        this.sounds.playerCaught.triggerAttackRelease(duration);
                    } else if (this.sounds[soundName] instanceof Tone.Synth || this.sounds[soundName] instanceof Tone.NoiseSynth) {
                        this.sounds[soundName].triggerAttackRelease(note, duration);
                    }
                } catch (e) {
                    console.error(`Error al reproducir sonido ${soundName}:`, e);
                }
            },

            startLoop(soundName) {
                if (!this.isInitialized || !this.sounds[soundName] || !(this.sounds[soundName] instanceof Tone.Loop) || Tone.context.state !== 'running') {
                    console.warn(`Loop "${soundName}" no se puede iniciar. Estado: ${this.isInitialized}, AudioContext: ${Tone.context.state}, Loop existe: ${!!(this.sounds[soundName] instanceof Tone.Loop)}`);
                    return;
                }
                if (this.sounds[soundName].state !== "started") {
                    this.sounds[soundName].start(0); 
                    console.log(`ŒªŒøœç "${soundName}" iniciado.`);
                }
            },

            stopLoop(soundName) {
                if (!this.isInitialized || !this.sounds[soundName] || !(this.sounds[soundName] instanceof Tone.Loop)) {
                    return;
                }
                if (this.sounds[soundName].state === "started") {
                    this.sounds[soundName].stop(); 
                    console.log(`ŒªŒøœç "${soundName}" detenido.`);
                }
            }
        };

        // ===============================================================
        // üìä CONSTANTES DEL JUEGO
        // ===============================================================
        const GAME_CONFIG = {
            CELL_SIZE: 30,
            PLAYER_SIZE: 20,
            GHOST_SIZE: 20,
            FRUIT_SIZE: 16,
            POWER_PELLET_SIZE: 20,
            GHOST_MOVE_INTERVAL: 1000, 
            MAX_LIVES: 8, 
            POWER_PELLET_COUNT: 2,
            VULNERABLE_TIME: 8000,
            POINTS: {
                FRUIT_BASIC: 5,
                QUESTION_EASY: 10,
                QUESTION_MEDIUM: 20,
                QUESTION_HARD: 30,
                QUESTION_EXPERT: 40,
                GHOST_EATEN: 50, 
                SPEED_BONUS: 5 
            },
            LEVELS: {
                easy: { name: "F√°cil", description: "Magnitudes fundamentales y Sistema Internacional", questionCount: 12, ghostCount: 1, ghostSpeed: 1200 },
                medium: { name: "Medio", description: "Cinem√°tica b√°sica y Movimiento Rectil√≠neo Uniforme", questionCount: 16, ghostCount: 2, ghostSpeed: 1000 },
                hard: { name: "Dif√≠cil", description: "MRUA, Movimiento Vertical y Ca√≠da Libre", questionCount: 20, ghostCount: 3, ghostSpeed: 800 },
                expert: { name: "Experto", description: "Movimiento Circular y Parab√≥lico Completo", questionCount: 25, ghostCount: 4, ghostSpeed: 600 }
            }
        };

        // ===============================================================
        // üìö BANCO DE PREGUNTAS MEJORADO POR TEMAS 
        // (Se mantiene el banco de preguntas original, omitido aqu√≠ por brevedad)
        // ===============================================================
        const QUESTION_BANK = {
            magnitudes: [
                { tema: "Magnitudes", question: "¬øCu√°l es la unidad fundamental del SI para la masa?", opciones: ["Gramo (g)", "Libra (lb)", "Kilogramo (kg)", "Onza (oz)"], respuestaCorrecta: "Kilogramo (kg)", explicacion: "El kilogramo es una de las 7 unidades fundamentales del Sistema Internacional." },
                { tema: "Magnitudes", question: "¬øCu√°l de estas es una magnitud escalar?", opciones: ["Velocidad", "Fuerza", "Temperatura", "Aceleraci√≥n"], respuestaCorrecta: "Temperatura", explicacion: "Las magnitudes escalares solo tienen valor num√©rico, sin direcci√≥n." },
                { tema: "Magnitudes", question: "¬øCu√°l de estas es una magnitud vectorial?", opciones: ["Masa", "Tiempo", "Desplazamiento", "Energ√≠a"], respuestaCorrecta: "Desplazamiento", explicacion: "Las magnitudes vectoriales tienen magnitud, direcci√≥n y sentido." },
                { tema: "Magnitudes", question: "¬øQu√© prefijo del SI representa 10^6?", opciones: ["Kilo", "Mega", "Giga", "Mili"], respuestaCorrecta: "Mega", explicacion: "Mega (M) equivale a un mill√≥n de veces la unidad base." },
                { tema: "Magnitudes", question: "¬øQu√© prefijo del SI representa 10^-3?", opciones: ["Micro", "Nano", "Mili", "Centi"], respuestaCorrecta: "Mili", explicacion: "Mili (m) equivale a una mil√©sima parte de la unidad base." },
                { tema: "Magnitudes", question: "¬øCu√°l es la unidad SI para la intensidad de corriente el√©ctrica?", opciones: ["Volt (V)", "Ohm (Œ©)", "Ampere (A)", "Watt (W)"], respuestaCorrecta: "Ampere (A)", explicacion: "El ampere es una de las 7 unidades fundamentales del SI." },
                { tema: "Magnitudes", question: "¬øCu√°l es la unidad SI para la cantidad de sustancia?", opciones: ["Mol (mol)", "Gramo (g)", "Litro (L)", "Metro c√∫bico (m¬≥)"], respuestaCorrecta: "Mol (mol)", explicacion: "El mol es la unidad fundamental para medir cantidad de sustancia." },
                { tema: "Magnitudes", question: "¬øCu√°ntos metros tiene 1 kil√≥metro?", opciones: ["100 m", "1000 m", "10000 m", "100000 m"], respuestaCorrecta: "1000 m", explicacion: "Kilo significa mil, por lo tanto 1 km = 1000 m." },
                { tema: "Magnitudes", question: "¬øCu√°l es la unidad SI para la temperatura termodin√°mica?", opciones: ["Celsius (¬∞C)", "Kelvin (K)", "Fahrenheit (¬∞F)", "Rankine (¬∞R)"], respuestaCorrecta: "Kelvin (K)", explicacion: "El kelvin es la unidad fundamental de temperatura en el SI." },
                { tema: "Magnitudes", question: "¬øQu√© representa el prefijo 'nano' en el SI?", opciones: ["10^-6", "10^-9", "10^-12", "10^-3"], respuestaCorrecta: "10^-9", explicacion: "Nano (n) representa una mil millon√©sima parte (10^-9)." },
                { tema: "Magnitudes", question: "¬øCu√°l de estas NO es una unidad fundamental del SI?", opciones: ["Metro", "Segundo", "Newton", "Kelvin"], respuestaCorrecta: "Newton", explicacion: "Newton es una unidad derivada (kg‚ãÖm‚ãÖs^-2), no fundamental." },
                { tema: "Magnitudes", question: "¬øQu√© magnitud mide la cantidad de materia en un objeto?", opciones: ["Peso", "Masa", "Volumen", "Densidad"], respuestaCorrecta: "Masa", explicacion: "La masa es invariante y mide la cantidad de materia." },
                { tema: "Magnitudes", question: "¬øCu√°l es la diferencia entre rapidez y velocidad?", opciones: [ "No hay diferencia", "Rapidez es escalar, velocidad es vectorial", "Rapidez es mayor que velocidad", "Velocidad es solo para movimiento recto" ], respuestaCorrecta: "Rapidez es escalar, velocidad es vectorial", explicacion: "Rapidez solo tiene magnitud, velocidad tiene magnitud y direcci√≥n." },
                { tema: "Magnitudes", question: "¬øCu√°ntos gramos hay en 2.5 kilogramos?", opciones: ["250 g", "2500 g", "25 g", "25000 g"], respuestaCorrecta: "2500 g", explicacion: "1 kg = 1000 g, entonces 2.5 kg = 2500 g." },
                { tema: "Magnitudes", question: "¬øQu√© prefijo representa 10^12?", opciones: ["Giga", "Tera", "Peta", "Mega"], respuestaCorrecta: "Tera", explicacion: "Tera (T) representa un bill√≥n de veces la unidad base." }
            ],
            cinematica: [
                { tema: "Cinem√°tica", question: "¬øQu√© es un sistema de referencia?", opciones: [ "Un punto fijo en el espacio", "Un conjunto de coordenadas para describir posici√≥n", "La velocidad de un objeto", "El origen de coordenadas √∫nicamente" ], respuestaCorrecta: "Un conjunto de coordenadas para describir posici√≥n", explicacion: "Un sistema de referencia permite ubicar objetos en el espacio y tiempo." },
                { tema: "Cinem√°tica", question: "¬øQu√© representa el vector de posici√≥n?", opciones: [ "La distancia recorrida", "La ubicaci√≥n de una part√≠cula respecto al origen", "La velocidad instant√°nea", "El tiempo transcurrido" ], respuestaCorrecta: "La ubicaci√≥n de una part√≠cula respecto al origen", explicacion: "El vector posici√≥n va del origen hasta la ubicaci√≥n de la part√≠cula." },
                { tema: "Cinem√°tica", question: "¬øCu√°l es la diferencia entre distancia y desplazamiento?", opciones: [ "No hay diferencia", "Distancia es escalar, desplazamiento es vectorial", "Desplazamiento es siempre mayor", "Distancia puede ser negativa" ], respuestaCorrecta: "Distancia es escalar, desplazamiento es vectorial", explicacion: "Distancia es la longitud total recorrida, desplazamiento es el cambio de posici√≥n." },
                { tema: "Cinem√°tica", question: "¬øCu√°ndo se dice que una part√≠cula est√° en reposo?", opciones: [ "Cuando no se mueve respecto a ning√∫n sistema", "Cuando su posici√≥n no cambia respecto al sistema de referencia", "Cuando su velocidad es muy peque√±a", "Cuando est√° en el origen de coordenadas" ], respuestaCorrecta: "Cuando su posici√≥n no cambia respecto al sistema de referencia", explicacion: "El reposo es relativo al sistema de referencia elegido." },
                { tema: "Cinem√°tica", question: "¬øQu√© es la trayectoria de una part√≠cula?", opciones: [ "Su velocidad final", "El conjunto de posiciones que ocupa durante su movimiento", "Su aceleraci√≥n promedio", "La distancia total recorrida" ], respuestaCorrecta: "El conjunto de posiciones que ocupa durante su movimiento", explicacion: "La trayectoria es la l√≠nea que describe el movimiento de la part√≠cula." },
                { tema: "Cinem√°tica", question: "¬øQu√© mide la velocidad instant√°nea?", opciones: [ "El desplazamiento total", "La rapidez promedio", "La rapidez y direcci√≥n en un instante espec√≠fico", "La aceleraci√≥n en ese momento" ], respuestaCorrecta: "La rapidez y direcci√≥n en un instante espec√≠fico", explicacion: "La velocidad instant√°nea es la derivada de la posici√≥n respecto al tiempo." },
                { tema: "Cinem√°tica", question: "¬øCu√°l es la unidad SI de la velocidad?", opciones: ["m/s", "km/h", "cm/s", "m/s¬≤"], respuestaCorrecta: "m/s", explicacion: "Metro por segundo es la unidad est√°ndar de velocidad en el SI." },
                { tema: "Cinem√°tica", question: "¬øQu√© representa la aceleraci√≥n?", opciones: [ "El cambio de posici√≥n", "El cambio de velocidad por unidad de tiempo", "La velocidad m√°xima", "La distancia recorrida" ], respuestaCorrecta: "El cambio de velocidad por unidad de tiempo", explicacion: "La aceleraci√≥n mide c√≥mo cambia la velocidad con el tiempo." },
                { tema: "Cinem√°tica", question: "¬øCu√°l es la unidad SI de la aceleraci√≥n?", opciones: ["m/s", "m/s¬≤", "N", "kg‚ãÖm/s"], respuestaCorrecta: "m/s¬≤", explicacion: "Metro por segundo al cuadrado es la unidad de aceleraci√≥n." },
                { tema: "Cinem√°tica", question: "¬øQu√© significa que el movimiento es relativo?", opciones: [ "Que depende del observador", "Que es muy lento", "Que cambia con el tiempo", "Que es aproximado" ], respuestaCorrecta: "Que depende del observador", explicacion: "El movimiento siempre se describe respecto a un sistema de referencia." },
                { tema: "Cinem√°tica", question: "Si un objeto regresa a su posici√≥n inicial, ¬øcu√°l es su desplazamiento?", opciones: ["Igual a la distancia recorrida", "Cero", "Depende del tiempo", "Infinito"], respuestaCorrecta: "Cero", explicacion: "El desplazamiento es el cambio neto de posici√≥n, no la distancia recorrida." },
                { tema: "Cinem√°tica", question: "¬øCu√°ndo la rapidez promedio es igual a la velocidad promedio?", opciones: [ "Siempre", "Nunca", "Cuando el movimiento es en l√≠nea recta y sin cambio de direcci√≥n", "Solo en ca√≠da libre" ], respuestaCorrecta: "Cuando el movimiento es en l√≠nea recta y sin cambio de direcci√≥n", explicacion: "En movimiento rectil√≠neo sin cambio de sentido, ambas coinciden." },
                { tema: "Cinem√°tica", question: "¬øQu√© estudia la cinem√°tica?", opciones: [ "Las causas del movimiento", "La descripci√≥n del movimiento sin considerar sus causas", "Solo el movimiento circular", "Las fuerzas aplicadas" ], respuestaCorrecta: "La descripci√≥n del movimiento sin considerar sus causas", explicacion: "La cinem√°tica describe c√≥mo se mueven los objetos, no por qu√©." },
                { tema: "Cinem√°tica", question: "¬øPuede un objeto tener velocidad cero y aceleraci√≥n no cero?", opciones: ["No, es imposible", "S√≠, en el punto m√°s alto de un lanzamiento vertical", "Solo en movimiento circular", "Solo en ca√≠da libre"], respuestaCorrecta: "S√≠, en el punto m√°s alto de un lanzamiento vertical", explicacion: "En el punto m√°s alto, v=0 pero a=-g (aceleraci√≥n gravitatoria)." },
                { tema: "Cinem√°tica", question: "¬øQu√© es una part√≠cula en f√≠sica?", opciones: [ "Un √°tomo", "Un objeto cuyas dimensiones son despreciables", "Una mol√©cula peque√±a", "Solo objetos microsc√≥picos" ], respuestaCorrecta: "Un objeto cuyas dimensiones son despreciables", explicacion: "Una part√≠cula es un modelo donde se ignoran las dimensiones del objeto." }
            ],
            mru: [
                { tema: "MRU", question: "En un MRU, ¬øc√≥mo es la velocidad?", opciones: ["Variable", "Constante", "Creciente", "Decreciente"], respuestaCorrecta: "Constante", explicacion: "En el MRU, la velocidad permanece constante en magnitud y direcci√≥n." },
                { tema: "MRU", question: "¬øCu√°l es la ecuaci√≥n correcta para la posici√≥n en MRU?", opciones: ["x = v¬≤t", "x = x‚ÇÄ + vt", "x = ¬Ωat¬≤", "x = vt¬≤"], respuestaCorrecta: "x = x‚ÇÄ + vt", explicacion: "En MRU, la posici√≥n es la posici√≥n inicial m√°s velocidad por tiempo." },
                { tema: "MRU", question: "En un MRU, ¬øcu√°l es la aceleraci√≥n?", opciones: ["Constante y diferente de cero", "Variable", "Cero", "Negativa"], respuestaCorrecta: "Cero", explicacion: "En MRU no hay cambio de velocidad, por lo tanto a = 0." },
                { tema: "MRU", question: "Si v = Œîx/Œît, ¬øqu√© representa esta ecuaci√≥n?", opciones: ["Aceleraci√≥n", "Velocidad promedio", "Fuerza", "Energ√≠a"], respuestaCorrecta: "Velocidad promedio", explicacion: "Es la definici√≥n de velocidad promedio: cambio de posici√≥n sobre tiempo." },
                { tema: "MRU", question: "Un auto viaja 120 km en 2 horas con MRU. ¬øCu√°l es su velocidad?", opciones: ["60 km/h", "240 km/h", "30 km/h", "90 km/h"], respuestaCorrecta: "60 km/h", explicacion: "v = Œîx/Œît = 120 km / 2 h = 60 km/h" },
                { tema: "MRU", question: "¬øCu√°l es la velocidad del sonido en el aire aproximadamente?", opciones: ["300 m/s", "340 m/s", "400 m/s", "280 m/s"], respuestaCorrecta: "340 m/s", explicacion: "La velocidad del sonido en aire a 20¬∞C es aproximadamente 340 m/s." },
                { tema: "MRU", question: "¬øCu√°l es la velocidad de la luz en el vac√≠o?", opciones: ["3√ó10‚Å∏ m/s", "3√ó10‚Å∂ m/s", "3√ó10¬π‚Å∞ m/s", "3√ó10‚Åµ m/s"], respuestaCorrecta: "3√ó10‚Å∏ m/s", explicacion: "La velocidad de la luz en el vac√≠o es 299,792,458 m/s ‚âà 3√ó10‚Å∏ m/s." },
                { tema: "MRU", question: "En MRU, si duplicamos el tiempo, ¬øqu√© pasa con la distancia recorrida?", opciones: ["Se mantiene igual", "Se duplica", "Se cuadruplica", "Se reduce a la mitad"], respuestaCorrecta: "Se duplica", explicacion: "En MRU, x ‚àù t, por lo tanto si t se duplica, x tambi√©n se duplica." },
                { tema: "MRU", question: "¬øC√≥mo es la gr√°fica velocidad vs. tiempo en un MRU?", opciones: ["Una l√≠nea recta horizontal", "Una l√≠nea inclinada", "Una par√°bola", "Una curva"], respuestaCorrecta: "Una l√≠nea recta horizontal", explicacion: "En MRU la velocidad es constante, generando una l√≠nea horizontal." },
                { tema: "MRU", question: "¬øC√≥mo es la gr√°fica posici√≥n vs. tiempo en un MRU?", opciones: ["Una l√≠nea horizontal", "Una l√≠nea recta inclinada", "Una par√°bola", "Una curva exponencial"], respuestaCorrecta: "Una l√≠nea recta inclinada", explicacion: "En MRU, x = x‚ÇÄ + vt es una funci√≥n lineal con pendiente v." },
                { tema: "MRU", question: "Si t = (x - x‚ÇÄ)/v, ¬øpara qu√© sirve esta ecuaci√≥n?", opciones: ["Calcular velocidad", "Calcular tiempo", "Calcular aceleraci√≥n", "Calcular fuerza"], respuestaCorrecta: "Calcular tiempo", explicacion: "Es el despeje de la ecuaci√≥n de MRU para encontrar el tiempo." },
                { tema: "MRU", question: "Un tren viaja a 80 km/h. ¬øCu√°nto tiempo tarda en recorrer 240 km?", opciones: ["2 horas", "3 horas", "4 horas", "5 horas"], respuestaCorrecta: "3 horas", explicacion: "t = x/v = 240 km / 80 km/h = 3 horas" },
                { tema: "MRU", question: "¬øQu√© significa que la velocidad sea constante?", opciones: [ "Solo la magnitud es constante", "Solo la direcci√≥n es constante", "Tanto magnitud como direcci√≥n son constantes", "Que no hay movimiento" ], respuestaCorrecta: "Tanto magnitud como direcci√≥n son constantes", explicacion: "Velocidad constante implica que no cambia ni su magnitud ni su direcci√≥n." },
                { tema: "MRU", question: "Si x‚ÇÄ = 10 m, v = 5 m/s y t = 4 s, ¬øcu√°l es la posici√≥n final?", opciones: ["30 m", "20 m", "25 m", "35 m"], respuestaCorrecta: "30 m", explicacion: "x = x‚ÇÄ + vt = 10 + 5(4) = 10 + 20 = 30 m" },
                { tema: "MRU", question: "En MRU, ¬øla distancia recorrida es igual al desplazamiento?", opciones: [ "Siempre", "Solo si no hay cambio de direcci√≥n", "Nunca", "Solo en movimiento circular" ], respuestaCorrecta: "Solo si no hay cambio de direcci√≥n", explicacion: "En MRU rectil√≠neo sin cambio de sentido, distancia = |desplazamiento|." }
            ],
            mrua: [
                { tema: "MRUA", question: "En MRUA, ¬øc√≥mo es la aceleraci√≥n?", opciones: ["Variable", "Constante", "Cero", "Infinita"], respuestaCorrecta: "Constante", explicacion: "En MRUA, la aceleraci√≥n permanece constante durante todo el movimiento." },
                { tema: "MRUA", question: "¬øCu√°l es la ecuaci√≥n correcta v = v‚ÇÄ + at?", opciones: ["Velocidad final", "Velocidad inicial", "Aceleraci√≥n", "Todas son correctas"], respuestaCorrecta: "Todas son correctas", explicacion: "Esta ecuaci√≥n relaciona velocidad final, inicial, aceleraci√≥n y tiempo." },
                { tema: "MRUA", question: "¬øCu√°l es la ecuaci√≥n para posici√≥n en MRUA?", opciones: ["x = vt", "x = x‚ÇÄ + v‚ÇÄt + ¬Ωat¬≤", "x = ¬Ωat", "x = v‚ÇÄ + at"], respuestaCorrecta: "x = x‚ÇÄ + v‚ÇÄt + ¬Ωat¬≤", explicacion: "Esta es la ecuaci√≥n cinem√°tica para posici√≥n en MRUA." },
                { tema: "MRUA", question: "¬øCu√°l es la ecuaci√≥n que NO involucra el tiempo?", opciones: ["v = v‚ÇÄ + at", "x = v‚ÇÄt + ¬Ωat¬≤", "v¬≤ = v‚ÇÄ¬≤ + 2ax", "x = (v + v‚ÇÄ)t/2"], respuestaCorrecta: "v¬≤ = v‚ÇÄ¬≤ + 2ax", explicacion: "Esta ecuaci√≥n relaciona velocidades, aceleraci√≥n y desplazamiento sin tiempo." },
                { tema: "MRUA", question: "¬øQu√© representa la ecuaci√≥n x = (v + v‚ÇÄ)t/2?", opciones: ["Velocidad promedio", "Posici√≥n usando velocidad promedio", "Aceleraci√≥n", "Tiempo"], respuestaCorrecta: "Posici√≥n usando velocidad promedio", explicacion: "Usa el hecho de que en MRUA, v_promedio = (v + v‚ÇÄ)/2." },
                { tema: "MRUA", question: "Si a = (v - v‚ÇÄ)/t, ¬øqu√© estamos calculando?", opciones: ["Velocidad", "Posici√≥n", "Aceleraci√≥n", "Tiempo"], respuestaCorrecta: "Aceleraci√≥n", explicacion: "Es la definici√≥n de aceleraci√≥n: cambio de velocidad sobre tiempo." },
                { tema: "MRUA", question: "Un objeto acelera desde reposo a 2 m/s¬≤ durante 5 s. ¬øCu√°l es su velocidad final?", opciones: ["7 m/s", "10 m/s", "12 m/s", "2.5 m/s"], respuestaCorrecta: "10 m/s", explicacion: "v = v‚ÇÄ + at = 0 + 2(5) = 10 m/s" },
                { tema: "MRUA", question: "¬øCu√°nta distancia recorre el objeto del problema anterior?", opciones: ["25 m", "50 m", "10 m", "20 m"], respuestaCorrecta: "25 m", explicacion: "x = v‚ÇÄt + ¬Ωat¬≤ = 0 + ¬Ω(2)(5¬≤) = 25 m" },
                { tema: "MRUA", question: "¬øC√≥mo es la gr√°fica velocidad vs. tiempo en MRUA?", opciones: ["L√≠nea horizontal", "L√≠nea recta inclinada", "Par√°bola", "Curva exponencial"], respuestaCorrecta: "L√≠nea recta inclinada", explicacion: "v = v‚ÇÄ + at es una funci√≥n lineal con pendiente a." },
                { tema: "MRUA", question: "¬øC√≥mo es la gr√°fica posici√≥n vs. tiempo en MRUA?", opciones: ["L√≠nea recta", "Par√°bola", "C√≠rculo", "L√≠nea horizontal"], respuestaCorrecta: "Par√°bola", explicacion: "x = x‚ÇÄ + v‚ÇÄt + ¬Ωat¬≤ es una funci√≥n cuadr√°tica." },
                { tema: "MRUA", question: "Un auto frena con a = -3 m/s¬≤ desde 30 m/s. ¬øCu√°nto tarda en detenerse?", opciones: ["10 s", "15 s", "5 s", "20 s"], respuestaCorrecta: "10 s", explicacion: "0 = 30 + (-3)t ‚Üí t = 30/3 = 10 s" },
                { tema: "MRUA", question: "¬øQu√© distancia recorre el auto al frenar del problema anterior?", opciones: ["150 m", "300 m", "450 m", "90 m"], respuestaCorrecta: "150 m", explicacion: "v¬≤ = v‚ÇÄ¬≤ + 2ax ‚Üí 0 = 900 + 2(-3)x ‚Üí x = 150 m" },
                { tema: "MRUA", question: "¬øCu√°l es la velocidad promedio en MRUA?", opciones: ["v‚ÇÄ", "v", "(v + v‚ÇÄ)/2", "at"], respuestaCorrecta: "(v + v‚ÇÄ)/2", explicacion: "En MRUA, la velocidad promedio es la media aritm√©tica de velocidades inicial y final." },
                { tema: "MRUA", question: "Si un objeto parte del reposo y acelera a 4 m/s¬≤, ¬øqu√© velocidad tiene a los 3 s?", opciones: ["12 m/s", "7 m/s", "4 m/s", "16 m/s"], respuestaCorrecta: "12 m/s", explicacion: "v = v‚ÇÄ + at = 0 + 4(3) = 12 m/s" },
                { tema: "MRUA", question: "¬øCu√°l es la diferencia principal entre MRU y MRUA?", opciones: [ "La velocidad inicial", "La presencia de aceleraci√≥n constante", "El tiempo de movimiento", "La direcci√≥n" ], respuestaCorrecta: "La presencia de aceleraci√≥n constante", explicacion: "En MRU a=0, en MRUA a=constante‚â†0." }
            ],
            vertical: [
                { tema: "Movimiento Vertical", question: "¬øCu√°l es el valor aproximado de la aceleraci√≥n gravitatoria en la Tierra?", opciones: ["9.8 m/s¬≤", "10 m/s¬≤", "8.9 m/s¬≤", "11 m/s¬≤"], respuestaCorrecta: "9.8 m/s¬≤", explicacion: "La aceleraci√≥n gravitatoria terrestre es g = 9.8 m/s¬≤ hacia abajo." },
                { tema: "Movimiento Vertical", question: "En ca√≠da libre, ¬øc√≥mo es la aceleraci√≥n?", opciones: ["Variable", "Cero", "Constante e igual a g", "Depende de la masa"], respuestaCorrecta: "Constante e igual a g", explicacion: "En ca√≠da libre, todos los objetos tienen aceleraci√≥n g, independiente de su masa." },
                { tema: "Movimiento Vertical", question: "Un objeto se lanza verticalmente hacia arriba. En el punto m√°s alto:", opciones: ["v = 0, a = 0", "v = 0, a = g", "v = m√°xima, a = 0", "v = g, a = 0"], respuestaCorrecta: "v = 0, a = g", explicacion: "En el punto m√°s alto, la velocidad es cero pero la aceleraci√≥n sigue siendo g." },
                { tema: "Movimiento Vertical", question: "¬øCu√°nto tiempo tarda un objeto en caer desde 45 m de altura?", opciones: ["3 s", "4 s", "2 s", "5 s"], respuestaCorrecta: "3 s", explicacion: "h = ¬Ωgt¬≤ ‚Üí 45 = ¬Ω(10)t¬≤ ‚Üí t¬≤ = 9 ‚Üí t = 3 s (usando g ‚âà 10 m/s¬≤)" },
                { tema: "Movimiento Vertical", question: "¬øCon qu√© velocidad llega al suelo el objeto del problema anterior?", opciones: ["30 m/s", "45 m/s", "20 m/s", "15 m/s"], respuestaCorrecta: "30 m/s", explicacion: "v = gt = 10(3) = 30 m/s" },
                { tema: "Movimiento Vertical", question: "Un objeto se lanza hacia arriba con v‚ÇÄ = 20 m/s. ¬øCu√°l es su altura m√°xima?", opciones: ["20 m", "40 m", "10 m", "30 m"], respuestaCorrecta: "20 m", explicacion: "v¬≤ = v‚ÇÄ¬≤ - 2gh ‚Üí 0 = 400 - 2(10)h ‚Üí h = 20 m" },
                { tema: "Movimiento Vertical", question: "¬øCu√°nto tiempo tarda en subir el objeto del problema anterior?", opciones: ["2 s", "4 s", "1 s", "3 s"], respuestaCorrecta: "2 s", explicacion: "v = v‚ÇÄ - gt ‚Üí 0 = 20 - 10t ‚Üí t = 2 s" },
                { tema: "Movimiento Vertical", question: "¬øCu√°nto tiempo total est√° en el aire el objeto lanzado hacia arriba?", opciones: ["2 s", "4 s", "6 s", "8 s"], respuestaCorrecta: "4 s", explicacion: "El tiempo total es el doble del tiempo de subida: 2 √ó 2 = 4 s" },
                { tema: "Movimiento Vertical", question: "En ausencia de resistencia del aire, ¬øqu√© objeto cae m√°s r√°pido?", opciones: ["El m√°s pesado", "El m√°s liviano", "Ambos igual", "Depende de la forma"], respuestaCorrecta: "Ambos igual", explicacion: "En el vac√≠o, todos los objetos caen con la misma aceleraci√≥n g." },
                { tema: "Movimiento Vertical", question: "¬øCu√°l es la ecuaci√≥n para la altura en ca√≠da libre desde el reposo?", opciones: ["h = vt", "h = ¬Ωgt¬≤", "h = gt", "h = v‚ÇÄt + ¬Ωgt¬≤"], respuestaCorrecta: "h = ¬Ωgt¬≤", explicacion: "Para ca√≠da libre desde reposo (v‚ÇÄ = 0): h = ¬Ωgt¬≤" },
                { tema: "Movimiento Vertical", question: "¬øQu√© es la ca√≠da libre?", opciones: [ "Cualquier movimiento hacia abajo", "Movimiento bajo la acci√≥n √∫nica de la gravedad", "Movimiento con velocidad constante", "Solo cuando se suelta desde reposo" ], respuestaCorrecta: "Movimiento bajo la acci√≥n √∫nica de la gravedad", explicacion: "Ca√≠da libre es movimiento donde solo act√∫a la gravedad (sin resistencia del aire)." },
                { tema: "Movimiento Vertical", question: "Un objeto cae durante 4 s. ¬øQu√© distancia recorre?", opciones: ["80 m", "160 m", "40 m", "120 m"], respuestaCorrecta: "80 m", explicacion: "h = ¬Ωgt¬≤ = ¬Ω(10)(4¬≤) = ¬Ω(10)(16) = 80 m" },
                { tema: "Movimiento Vertical", question: "¬øPor qu√© g se considera negativa en lanzamiento vertical?", opciones: [ "Porque es hacia abajo", "Por convenio de signos", "Porque frena el movimiento ascendente", "Todas las anteriores" ], respuestaCorrecta: "Todas las anteriores", explicacion: "g es negativa por convenio cuando el eje y es positivo hacia arriba." },
                { tema: "Movimiento Vertical", question: "¬øCon qu√© velocidad debe lanzarse un objeto para que alcance 80 m de altura?", opciones: ["40 m/s", "20 m/s", "30 m/s", "50 m/s"], respuestaCorrecta: "40 m/s", explicacion: "v‚ÇÄ¬≤ = 2gh = 2(10)(80) = 1600 ‚Üí v‚ÇÄ = 40 m/s" },
                { tema: "Movimiento Vertical", question: "¬øQu√© velocidad tiene un objeto despu√©s de caer 20 m?", opciones: ["20 m/s", "30 m/s", "40 m/s", "10 m/s"], respuestaCorrecta: "20 m/s", explicacion: "v¬≤ = 2gh = 2(10)(20) = 400 ‚Üí v = 20 m/s" }
            ],
            circular: [
                { tema: "Movimiento Circular", question: "¬øC√≥mo se define el √°ngulo en radianes?", opciones: ["Œ∏ = s/r", "Œ∏ = r/s", "Œ∏ = s√ór", "Œ∏ = 2œÄr"], respuestaCorrecta: "Œ∏ = s/r", explicacion: "El √°ngulo en radianes es la raz√≥n entre el arco y el radio." },
                { tema: "Movimiento Circular", question: "¬øCu√°ntos radianes hay en una vuelta completa?", opciones: ["œÄ", "2œÄ", "œÄ/2", "4œÄ"], respuestaCorrecta: "2œÄ", explicacion: "Una vuelta completa corresponde a 2œÄ radianes = 360¬∞." },
                { tema: "Movimiento Circular", question: "¬øCu√°l es la ecuaci√≥n de velocidad lineal en MCU?", opciones: ["v = œâr", "v = œâ/r", "v = r/œâ", "v = œâ¬≤r"], respuestaCorrecta: "v = œâr", explicacion: "La velocidad lineal es el producto de velocidad angular por radio." },
                { tema: "Movimiento Circular", question: "¬øC√≥mo se define la velocidad angular?", opciones: ["œâ = Œ∏/t", "œâ = t/Œ∏", "œâ = Œ∏√ót", "œâ = r/t"], respuestaCorrecta: "œâ = Œ∏/t", explicacion: "Velocidad angular es el √°ngulo recorrido por unidad de tiempo." },
                { tema: "Movimiento Circular", question: "¬øCu√°l es la relaci√≥n entre velocidad angular y per√≠odo?", opciones: ["œâ = T", "œâ = 2œÄ/T", "œâ = œÄ/T", "œâ = T/2œÄ"], respuestaCorrecta: "œâ = 2œÄ/T", explicacion: "En un per√≠odo T se recorre 2œÄ radianes, entonces œâ = 2œÄ/T." },
                { tema: "Movimiento Circular", question: "¬øQu√© es el per√≠odo T en MCU?", opciones: [ "El tiempo para recorrer medio c√≠rculo", "El tiempo para una vuelta completa", "La velocidad angular", "El radio del c√≠rculo" ], respuestaCorrecta: "El tiempo para una vuelta completa", explicacion: "El per√≠odo es el tiempo que tarda en completar una revoluci√≥n." },
                { tema: "Movimiento Circular", question: "¬øC√≥mo se define la frecuencia f?", opciones: ["f = T", "f = 1/T", "f = 2œÄT", "f = T/2œÄ"], respuestaCorrecta: "f = 1/T", explicacion: "La frecuencia es el n√∫mero de vueltas por unidad de tiempo: f = 1/T." },
                { tema: "Movimiento Circular", question: "¬øCu√°l es la unidad SI de velocidad angular?", opciones: ["rad", "rad/s", "Hz", "rpm"], respuestaCorrecta: "rad/s", explicacion: "La velocidad angular se mide en radianes por segundo." },
                { tema: "Movimiento Circular", question: "¬øHacia d√≥nde apunta la aceleraci√≥n centr√≠peta?", opciones: ["Tangente al c√≠rculo", "Hacia el centro", "Hacia afuera", "Variable"], respuestaCorrecta: "Hacia el centro", explicacion: "La aceleraci√≥n centr√≠peta siempre apunta hacia el centro del c√≠rculo." },
                { tema: "Movimiento Circular", question: "¬øCu√°l es la f√≥rmula de aceleraci√≥n centr√≠peta?", opciones: ["ac = v¬≤/r", "ac = vr", "ac = v/r", "ac = r/v"], respuestaCorrecta: "ac = v¬≤/r", explicacion: "La aceleraci√≥n centr√≠peta es ac = v¬≤/r = œâ¬≤r." },
                { tema: "Movimiento Circular", question: "Un objeto gira con œâ = 4 rad/s en un c√≠rculo de r = 2 m. ¬øCu√°l es su velocidad lineal?", opciones: ["2 m/s", "8 m/s", "6 m/s", "4 m/s"], respuestaCorrecta: "8 m/s", explicacion: "v = œâr = 4 √ó 2 = 8 m/s" },
                { tema: "Movimiento Circular", question: "¬øCu√°l es la aceleraci√≥n centr√≠peta del objeto anterior?", opciones: ["16 m/s¬≤", "32 m/s¬≤", "8 m/s¬≤", "24 m/s¬≤"], respuestaCorrecta: "32 m/s¬≤", explicacion: "ac = v¬≤/r = 8¬≤/2 = 64/2 = 32 m/s¬≤ o ac = œâ¬≤r = 4¬≤√ó2 = 32 m/s¬≤" },
                { tema: "Movimiento Circular", question: "Si T = 4 s, ¬øcu√°l es la frecuencia?", opciones: ["4 Hz", "0.25 Hz", "2 Hz", "8 Hz"], respuestaCorrecta: "0.25 Hz", explicacion: "f = 1/T = 1/4 = 0.25 Hz" },
                { tema: "Movimiento Circular", question: "¬øCu√°l es la velocidad angular si T = 2 s?", opciones: ["œÄ rad/s", "2œÄ rad/s", "œÄ/2 rad/s", "4œÄ rad/s"], respuestaCorrecta: "œÄ rad/s", explicacion: "œâ = 2œÄ/T = 2œÄ/2 = œÄ rad/s" },
                { tema: "Movimiento Circular", question: "En MCU, ¬øcambia la velocidad?", opciones: [ "No cambia nada", "Cambia la direcci√≥n pero no la magnitud", "Cambia la magnitud pero no la direcci√≥n", "Cambian ambas" ], respuestaCorrecta: "Cambia la direcci√≥n pero no la magnitud", explicacion: "En MCU, |v| = constante pero la direcci√≥n cambia continuamente." }
            ],
            parabolico: [
                { tema: "Movimiento Parab√≥lico", question: "¬øC√≥mo es el movimiento en el eje horizontal en tiro parab√≥lico?", opciones: ["MRU", "MRUA", "Circular", "Variable"], respuestaCorrecta: "MRU", explicacion: "En el eje x no hay aceleraci√≥n, por lo tanto es MRU: x = v‚ÇÄ‚Çìt" },
                { tema: "Movimiento Parab√≥lico", question: "¬øC√≥mo es el movimiento en el eje vertical en tiro parab√≥lico?", opciones: ["MRU", "MRUA", "Circular", "Sin movimiento"], respuestaCorrecta: "MRUA", explicacion: "En el eje y act√∫a la gravedad, generando MRUA con a = -g." },
                { tema: "Movimiento Parab√≥lico", question: "¬øCu√°les son las componentes de velocidad inicial con √°ngulo Œ∏?", opciones: [ "v‚ÇÄ‚Çì = v‚ÇÄsenŒ∏, v‚ÇÄ·µß = v‚ÇÄcosŒ∏", "v‚ÇÄ‚Çì = v‚ÇÄcosŒ∏, v‚ÇÄ·µß = v‚ÇÄsenŒ∏", "v‚ÇÄ‚Çì = v‚ÇÄtanŒ∏, v‚ÇÄ·µß = v‚ÇÄ", "v‚ÇÄ‚Çì = v‚ÇÄ, v‚ÇÄ·µß = v‚ÇÄtanŒ∏" ], respuestaCorrecta: "v‚ÇÄ‚Çì = v‚ÇÄcosŒ∏, v‚ÇÄ·µß = v‚ÇÄsenŒ∏", explicacion: "La componente horizontal es v‚ÇÄcosŒ∏ y la vertical es v‚ÇÄsenŒ∏." },
                { tema: "Movimiento Parab√≥lico", question: "¬øCu√°l es el tiempo de vuelo para un proyectil lanzado desde el suelo?", opciones: ["t = v‚ÇÄ/g", "t = 2v‚ÇÄsenŒ∏/g", "t = v‚ÇÄsenŒ∏/g", "t = v‚ÇÄcosŒ∏/g"], respuestaCorrecta: "t = 2v‚ÇÄsenŒ∏/g", explicacion: "El tiempo de vuelo es el doble del tiempo para alcanzar la altura m√°xima." },
                { tema: "Movimiento Parab√≥lico", question: "¬øCu√°l es la altura m√°xima en tiro parab√≥lico?", opciones: [ "h = v‚ÇÄ¬≤/2g", "h = v‚ÇÄ¬≤sen¬≤Œ∏/2g", "h = v‚ÇÄ¬≤cos¬≤Œ∏/2g", "h = v‚ÇÄ¬≤tan¬≤Œ∏/2g" ], respuestaCorrecta: "h = v‚ÇÄ¬≤sen¬≤Œ∏/2g", explicacion: "La altura m√°xima depende solo de la componente vertical inicial." },
                { tema: "Movimiento Parab√≥lico", question: "¬øCu√°l es el alcance horizontal m√°ximo?", opciones: [ "R = v‚ÇÄ¬≤/g", "R = v‚ÇÄ¬≤sen2Œ∏/g", "R = v‚ÇÄ¬≤cos2Œ∏/g", "R = 2v‚ÇÄ¬≤senŒ∏/g" ], respuestaCorrecta: "R = v‚ÇÄ¬≤sen2Œ∏/g", explicacion: "El alcance horizontal es R = v‚ÇÄ¬≤sen2Œ∏/g." },
                { tema: "Movimiento Parab√≥lico", question: "¬øCon qu√© √°ngulo se obtiene el alcance m√°ximo?", opciones: ["30¬∞", "45¬∞", "60¬∞", "90¬∞"], respuestaCorrecta: "45¬∞", explicacion: "sen2Œ∏ es m√°ximo cuando 2Œ∏ = 90¬∞, es decir Œ∏ = 45¬∞." },
                { tema: "Movimiento Parab√≥lico", question: "¬øCu√°ndo la velocidad es m√≠nima en tiro parab√≥lico?", opciones: [ "Al inicio", "En el punto m√°s alto", "Al final", "A la mitad del recorrido" ], respuestaCorrecta: "En el punto m√°s alto", explicacion: "En el punto m√°s alto, v·µß = 0, quedando solo v‚Çì = v‚ÇÄcosŒ∏." },
                { tema: "Movimiento Parab√≥lico", question: "¬øQu√© forma tiene la trayectoria en tiro parab√≥lico?", opciones: ["L√≠nea recta", "C√≠rculo", "Par√°bola", "Elipse"], respuestaCorrecta: "Par√°bola", explicacion: "La ecuaci√≥n de trayectoria es y = xtanŒ∏ - gx¬≤/(2v‚ÇÄ¬≤cos¬≤Œ∏), que es una par√°bola." },
                { tema: "Movimiento Parab√≥lico", question: "Un proyectil se lanza a 20 m/s con 30¬∞. ¬øCu√°l es v‚ÇÄ‚Çì?", opciones: ["10 m/s", "17.3 m/s", "20 m/s", "15 m/s"], respuestaCorrecta: "17.3 m/s", explicacion: "v‚ÇÄ‚Çì = v‚ÇÄcos30¬∞ = 20 √ó 0.866 = 17.3 m/s" },
                { tema: "Movimiento Parab√≥lico", question: "¬øCu√°l es v‚ÇÄ·µß del proyectil anterior?", opciones: ["10 m/s", "17.3 m/s", "20 m/s", "15 m/s"], respuestaCorrecta: "10 m/s", explicacion: "v‚ÇÄ·µß = v‚ÇÄsen30¬∞ = 20 √ó 0.5 = 10 m/s" },
                { tema: "Movimiento Parab√≥lico", question: "¬øCu√°nto tiempo tarda en alcanzar la altura m√°xima el proyectil anterior?", opciones: ["1 s", "2 s", "0.5 s", "1.5 s"], respuestaCorrecta: "1 s", explicacion: "t = v‚ÇÄ·µß/g = 10/10 = 1 s (usando g = 10 m/s¬≤)" },
                { tema: "Movimiento Parab√≥lico", question: "¬øCu√°l es la altura m√°xima del proyectil anterior?", opciones: ["5 m", "10 m", "2.5 m", "7.5 m"], respuestaCorrecta: "5 m", explicacion: "h = v‚ÇÄ·µß¬≤/2g = 10¬≤/(2√ó10) = 100/20 = 5 m" },
                { tema: "Movimiento Parab√≥lico", question: "¬øCu√°l es el tiempo total de vuelo del proyectil anterior?", opciones: ["1 s", "2 s", "3 s", "4 s"], respuestaCorrecta: "2 s", explicacion: "Tiempo total = 2 √ó tiempo de subida = 2 √ó 1 = 2 s" },
                { tema: "Movimiento Parab√≥lico", question: "¬øCu√°l es el alcance horizontal del proyectil anterior?", opciones: ["34.6 m", "20 m", "30 m", "40 m"], respuestaCorrecta: "34.6 m", explicacion: "R = v‚ÇÄ‚Çì √ó t_total = 17.3 √ó 2 = 34.6 m" }
            ]
        };
        
        // ===============================================================
        // üéØ CONFIGURACI√ìN DE NIVELES CON PREGUNTAS ESPEC√çFICAS
        // ===============================================================
        const LEVEL_QUESTIONS = {
            easy: { temas: ["magnitudes", "cinematica"], distribucion: { magnitudes: 8, cinematica: 4 } },
            medium: { temas: ["mru", "mrua"], distribucion: { mru: 8, mrua: 8 } },
            hard: { temas: ["mrua", "vertical"], distribucion: { mrua: 7, vertical: 13 } },
            expert: { temas: ["circular", "parabolico"], distribucion: { circular: 12, parabolico: 13 } }
        };

        // ===============================================================
        // üéÆ ESTADO GLOBAL DEL JUEGO - INICIALIZACI√ìN
        // ===============================================================
        const gameState = {
            level: "easy",
            gameStarted: false,
            gameCompleted: false,
            paused: false,
            playerPosition: { x: 1, y: 1 },
            playerDirection: "right",
            fruits: [],
            walls: [],
            ghosts: [],
            pacmanEl: null,
            score: 0,
            lives: GAME_CONFIG.MAX_LIVES,
            fruitCollected: 0,
            totalFruits: 0,
            questionsAnswered: 0,
            totalQuestionsInLevel: 0,
            correctAnswers: 0,
            currentQuestion: null,
            questionPool: [],
            usedQuestions: [],
            mazeWidth: 0,
            mazeHeight: 0,
            finalGrade: 0,
            ghostMovementInterval: null,
            vulnerableGhostsTimer: null,
            questionStartTime: null,
            questionTimerInterval: null,
            ghostsVulnerable: false,
            powerPelletActive: false,
        };

        // ===============================================================
        // üìã CONFIGURACI√ìN DEL LABERINTO - MEJORADA
        // ===============================================================
        const mazeLayout = {
            width: 17, 
            height: 11,
            walls: [
                ...Array.from({ length: 17 }, (_, i) => ({ x: i, y: 0 })),
                ...Array.from({ length: 17 }, (_, i) => ({ x: i, y: 10 })),
                ...Array.from({ length: 9 }, (_, i) => ({ x: 0, y: i + 1 })),
                ...Array.from({ length: 9 }, (_, i) => ({ x: 16, y: i + 1 })),
                { x: 2, y: 2 }, { x: 3, y: 2 }, { x: 4, y: 2 }, 
                { x: 6, y: 2 }, { x: 7, y: 2 }, { x: 8, y: 2 }, { x: 9, y: 2 }, { x: 10, y: 2 },
                { x: 12, y: 2 }, { x: 13, y: 2 }, { x: 14, y: 2 },
                { x: 2, y: 4 }, { x: 4, y: 4 }, { x: 6, y: 4 }, { x: 10, y: 4 }, { x: 12, y: 4 }, { x: 14, y: 4 },
                { x: 2, y: 6 }, { x: 4, y: 6 }, { x: 6, y: 6 }, { x: 10, y: 6 }, { x: 12, y: 6 }, { x: 14, y: 6 },
                { x: 2, y: 8 }, { x: 3, y: 8 }, { x: 4, y: 8 },
                { x: 6, y: 8 }, { x: 7, y: 8 }, { x: 8, y: 8 }, { x: 9, y: 8 }, { x: 10, y: 8 },
                { x: 12, y: 8 }, { x: 13, y: 8 }, { x: 14, y: 8 }
            ],
            fruits: [
                { x: 1, y: 1 }, { x: 5, y: 1 }, { x: 8, y: 1 }, { x: 11, y: 1 }, { x: 15, y: 1 },
                { x: 1, y: 3 }, { x: 3, y: 3 }, { x: 5, y: 3 }, { x: 8, y: 3 }, { x: 11, y: 3 }, { x: 13, y: 3 }, { x: 15, y: 3 },
                { x: 1, y: 5 }, { x: 3, y: 5 }, { x: 5, y: 5 }, { x: 8, y: 5 }, { x: 11, y: 5 }, { x: 13, y: 5 }, { x: 15, y: 5 },
                { x: 1, y: 7 }, { x: 5, y: 7 }, { x: 8, y: 7 }, { x: 11, y: 7 }, { x: 15, y: 7 },
                { x: 1, y: 9 }, { x: 5, y: 9 }, { x: 8, y: 9 }, { x: 11, y: 9 }, { x: 15, y: 9 }
            ]
        };
        const mazeConfigs = {
            easy: mazeLayout, medium: mazeLayout, hard: mazeLayout, expert: mazeLayout
        };

        // ===============================================================
        // üîß FUNCIONES UTILITARIAS DEL JUEGO
        // ===============================================================
        /**
         * Inicializa el pool de preguntas por nivel.
         * Selecciona preguntas espec√≠ficas seg√∫n la configuraci√≥n del nivel.
         */
        function initializeQuestionPool() {
            console.log(`üéØ Inicializando pool de preguntas para nivel: ${gameState.level}`);
            const levelConfig = LEVEL_QUESTIONS[gameState.level];
            const selectedQuestions = [];

            levelConfig.temas.forEach(tema => {
                const cantidadRequerida = levelConfig.distribucion[tema];
                const preguntasDelTema = QUESTION_BANK[tema] || [];
                const preguntasMezcladas = [...preguntasDelTema].sort(() => Math.random() - 0.5);
                const preguntasSeleccionadasParaTema = preguntasMezcladas.slice(0, cantidadRequerida);
                selectedQuestions.push(...preguntasSeleccionadasParaTema);
                console.log(`üìö ${tema}: ${preguntasSeleccionadasParaTema.length}/${cantidadRequerida} preguntas`);
            });

            gameState.questionPool = selectedQuestions.sort(() => Math.random() - 0.5);
            gameState.totalQuestionsInLevel = gameState.questionPool.length;
            gameState.usedQuestions = [];
            console.log(`‚úÖ Pool inicializado: ${gameState.totalQuestionsInLevel} preguntas totales`);
        }

        /**
         * Obtiene la pr√≥xima pregunta disponible.
         * @returns {Object|null} Pregunta o null si no hay m√°s.
         */
        function getNextQuestion() {
            if (!Array.isArray(gameState.questionPool)) {
                console.error("‚ùå Question pool no es un array.");
                gameState.questionPool = [];
            }
            if (gameState.questionPool.length === 0) {
                console.log("‚ö†Ô∏è No hay m√°s preguntas disponibles en el pool.");
                return null;
            }
            const question = gameState.questionPool.pop();
            gameState.usedQuestions.push(question);
            return question;
        }

        /**
         * Calcula la calificaci√≥n final del estudiante.
         * @returns {number} Calificaci√≥n entre 0 y 5.
         */
        function calculateFinalGrade() {
            const totalQuestionsActuallyAssigned = gameState.fruits.filter(f => f.question).length;
            const correctAnswers = gameState.correctAnswers;
            const livesLost = GAME_CONFIG.MAX_LIVES - gameState.lives;

            if (totalQuestionsActuallyAssigned === 0) {
                let baseScoreForCompletion = 0;
                if (gameState.totalFruits > 0 && gameState.fruitCollected === gameState.totalFruits) {
                    baseScoreForCompletion = 3.5;
                } else if (gameState.totalFruits > 0) {
                    baseScoreForCompletion = 2.0 * (gameState.fruitCollected / gameState.totalFruits);
                }
                const lifePenalty = Math.min(livesLost * 0.25, baseScoreForCompletion);
                return Math.max(0, baseScoreForCompletion - lifePenalty).toFixed(1);
            }
            
            const questionsToEvaluate = gameState.questionsAnswered > 0 ? gameState.questionsAnswered : totalQuestionsActuallyAssigned;
            if (questionsToEvaluate === 0) return 0; 

            const accuracyRatio = gameState.correctAnswers / questionsToEvaluate;
            const lifePenalty = Math.min(livesLost * 0.125, 1.0); 
            let grade = accuracyRatio * 5.0;
            grade = Math.max(0, grade - lifePenalty);

            if (gameState.fruitCollected === gameState.totalFruits && gameState.totalFruits > 0) {
                grade += 0.2; 
            }
            grade = Math.min(5.0, Math.max(0, grade));

            console.log(`üìä Calificaci√≥n calculada: ${grade.toFixed(1)}/5.0`);
            return grade;
        }

        /**
         * Obtiene mensaje motivacional seg√∫n la calificaci√≥n.
         * @param {number} grade Calificaci√≥n entre 0 y 5.
         * @returns {string} Mensaje motivacional.
         */
        function getFinalMessage(grade) {
            grade = parseFloat(grade);
            if (grade >= 4.7) return "üèÜ ¬°EXCELENTE! Dominas completamente estos conceptos de f√≠sica. ¬°Eres un verdadero cient√≠fico!";
            if (grade >= 4.0) return "üåü ¬°MUY BIEN! Tienes un s√≥lido entendimiento de la f√≠sica. ¬°Sigue as√≠!";
            if (grade >= 3.0) return "üëç ¬°BIEN! Entiendes los conceptos b√°sicos. Con un poco m√°s de pr√°ctica ser√°s excelente.";
            if (grade >= 2.0) return "üìö Necesitas reforzar algunos conceptos. ¬°No te desanimes, la pr√°ctica hace al maestro!";
            return "üí™ ¬°√Ånimo! La f√≠sica requiere pr√°ctica. Revisa los conceptos b√°sicos y vuelve a intentarlo.";
        }

        /**
         * Obtiene descripci√≥n detallada del nivel.
         * @param {string} level Nivel del juego.
         * @returns {string} Descripci√≥n del nivel.
         */
        function getLevelDescription(level) {
            const config = GAME_CONFIG.LEVELS[level];
            const levelQuestions = LEVEL_QUESTIONS[level];
            let description = `<p><strong>${config.description}</strong></p>`;
            description += `<p>üìä ${config.questionCount} preguntas objetivo | üëª ${config.ghostCount} fantasma(s)</p>`;
            const temas = levelQuestions.temas.map(tema => {
                const cantidad = levelQuestions.distribucion[tema];
                const nombreTema = {
                    magnitudes: "Magnitudes y SI", cinematica: "Cinem√°tica b√°sica", 
                    mru: "MRU", mrua: "MRUA", vertical: "Movimiento vertical",
                    circular: "Movimiento circular", parabolico: "Movimiento parab√≥lico"
                };
                return `${nombreTema[tema]} (${cantidad})`;
            }).join(" + ");
            description += `<p class="text-sm">üéØ Temas: ${temas}</p>`;
            return description;
        }

        // ===============================================================
        // üì± REFERENCIAS DOM Y DETECCI√ìN DE DISPOSITIVO
        // ===============================================================
        const appElement = document.getElementById("app");
        const questionDialog = document.getElementById("questionDialog");
        const completionDialog = document.getElementById("completionDialog");
        const helpDialog = document.getElementById("helpDialog");
        const toastContainer = document.getElementById("toastContainer");
        const globalPauseBtn = document.getElementById("globalPauseBtn");
        const globalResetBtn = document.getElementById("globalResetBtn");
        const isMobile = window.matchMedia("(max-width: 768px)").matches;

        // ===============================================================
        // üéÆ FUNCIONES PRINCIPALES DE INICIALIZACI√ìN
        // ===============================================================
        function renderApp() {
            console.log(`üéÆ Renderizando app - Estado: ${gameState.gameStarted ? 'Juego' : 'Selector'}`);
            if (!gameState.gameStarted) {
                renderLevelSelector();
            } else {
                renderGame();
            }
        }

        function renderLevelSelector() {
            console.log("üéØ Renderizando selector de niveles");
            appElement.innerHTML = `
                <div class="level-selector card">
                    <h2>Selecciona tu Nivel de Desaf√≠o</h2>
                    <p>Explora diferentes temas de f√≠sica mientras juegas. Recolecta frutas üçé para responder preguntas,
                        power pellets üíä para ganar vidas y evita los fantasmas üëª. ¬°Tu conocimiento es tu poder!</p>
                    <div class="level-tabs">
                        ${Object.keys(GAME_CONFIG.LEVELS).map(levelKey => `
                            <button class="level-tab ${gameState.level === levelKey ? 'active' : ''}" data-level="${levelKey}">
                                ${GAME_CONFIG.LEVELS[levelKey].name}
                            </button>
                        `).join('')}
                    </div>
                    <div class="level-description">${getLevelDescription(gameState.level)}</div>
                    <div id="buttonContainer">
                        <button id="startGameBtn" class="button button-primary">üöÄ ¬°Comenzar Aventura F√≠sica!</button>
                        <button id="helpBtn" class="button button-help">‚ùì ¬øC√≥mo Jugar?</button>
                    </div>
                </div>`;
            
            document.querySelectorAll(".level-tab").forEach(tab => {
                tab.addEventListener("click", () => {
                    soundManager.init().then(() => soundManager.play('buttonClick', 'C5', '16n'));
                    const newLevel = tab.getAttribute("data-level");
                    if (newLevel !== gameState.level) {
                        gameState.level = newLevel;
                        console.log(`üîÑ Nivel cambiado a: ${newLevel}`);
                        renderLevelSelector(); 
                    }
                });
            });

            document.getElementById("startGameBtn").addEventListener("click", () => {
                soundManager.init().then(() => { 
                    soundManager.play('buttonClick', 'E5', '16n');
                    startGame();
                });
            });

            document.getElementById("helpBtn").addEventListener("click", () => {
                soundManager.init().then(() => soundManager.play('buttonClick', 'D5', '16n'));
                showHelpDialog();
            });
        }
        
        function showHelpDialog() {
            console.log("‚ùì Mostrando di√°logo de ayuda");
            const helpContent = `
                <div class="dialog-content">
                    <div class="dialog-header">
                        <h2 class="dialog-title">üéÆ ¬øC√≥mo Jugar?</h2>
                        <p class="dialog-description">Gu√≠a completa del Laberinto de F√≠sica</p>
                    </div>
                    <div class="dialog-body">
                        <h3>üéØ Objetivo:</h3>
                        <p>Controla al Pac-Man üü° para recolectar todas las frutas del laberinto mientras respondes preguntas de f√≠sica y evitas a los fantasmas üëª.</p>
                        <h3>üïπÔ∏è Controles:</h3>
                        <ul>
                            <li><strong>Teclado:</strong> Usa las flechas ‚¨ÜÔ∏è‚¨áÔ∏è‚¨ÖÔ∏è‚û°Ô∏è para moverte</li>
                            <li><strong>M√≥vil:</strong> Toca los botones direccionales en pantalla</li>
                        </ul>
                        <h3>üéÆ Elementos del Juego:</h3>
                        <ul>
                            <li><strong>Frutas üçéüçåüçá:</strong> Al recolectarlas aparece una pregunta de f√≠sica. ¬°Responde correctamente para ganar puntos!</li>
                            <li><strong>Power Pellets üíä:</strong> Te dan una vida extra y temporalmente puedes "comer" fantasmas</li>
                            <li><strong>Fantasmas üëª:</strong> Te persiguen. Si te tocan pierdes una vida</li>
                        </ul>
                    </div>
                    <div class="dialog-footer">
                        <button id="closeHelpBtnDialog" class="button button-secondary">‚úÖ ¬°Entendido!</button>
                    </div>
                </div>`;
            helpDialog.innerHTML = helpContent;
            helpDialog.style.display = 'flex';
            helpDialog.querySelector('#closeHelpBtnDialog').addEventListener("click", () => {
                soundManager.init().then(() => soundManager.play('buttonClick', 'C5', '16n'));
                helpDialog.style.display = 'none';
            });
        }
        
        // ===============================================================
        // üöÄ FUNCI√ìN DE INICIO DEL JUEGO
        // ===============================================================
        function startGame() {
            console.log(`üöÄ Iniciando juego en nivel: ${gameState.level}`);
            // soundManager.init() es llamado por el bot√≥n, aqu√≠ solo reproducimos el sonido de inicio.
            soundManager.play('gameStart', 'C4', '1n');

            gameState.gameStarted = true;
            gameState.gameCompleted = false;
            gameState.paused = false;
            gameState.score = 0;
            gameState.lives = GAME_CONFIG.MAX_LIVES;
            gameState.questionsAnswered = 0;
            gameState.correctAnswers = 0;
            gameState.fruitCollected = 0;
            gameState.ghostsVulnerable = false;
            gameState.powerPelletActive = false;

            initializeMaze(); 
            initializeQuestionPool();
            assignQuestionsAndPellets(); 

            renderApp();
            attachEventHandlers();

            if (gameState.ghostMovementInterval) clearInterval(gameState.ghostMovementInterval);
            const ghostSpeed = GAME_CONFIG.LEVELS[gameState.level].ghostSpeed;
            gameState.ghostMovementInterval = setInterval(moveGhosts, ghostSpeed);

            globalPauseBtn.textContent = "‚è∏Ô∏è Pausar";
            globalPauseBtn.disabled = false;
            console.log("‚úÖ Juego iniciado correctamente");
        }

        // ===============================================================
        // üéÆ RENDERIZADO DEL JUEGO PRINCIPAL
        // ===============================================================
        function renderGame() {
            console.log("üé® Renderizando interfaz de juego");
            const config = mazeConfigs[gameState.level] || mazeConfigs.easy;
            gameState.mazeWidth = config.width;
            gameState.mazeHeight = config.height;

            const availableWidth = Math.min(window.innerWidth - 40, 1000);
            const calculatedCellSize = Math.floor(availableWidth / gameState.mazeWidth);
            const finalCellSize = Math.max(25, Math.min(GAME_CONFIG.CELL_SIZE, calculatedCellSize));

            const mazePixelWidth = gameState.mazeWidth * finalCellSize;
            const mazePixelHeight = gameState.mazeHeight * finalCellSize;
            const playerPixelSize = Math.floor(finalCellSize * 0.7);
            const ghostPixelSize = Math.floor(finalCellSize * 0.7);
            const fruitPixelSize = Math.floor(finalCellSize * 0.5);
            const powerPelletPixelSize = Math.floor(finalCellSize * 0.7);

            document.documentElement.style.setProperty('--cell-size', `${finalCellSize}px`);
            document.documentElement.style.setProperty('--player-size', `${playerPixelSize}px`);
            document.documentElement.style.setProperty('--ghost-size', `${ghostPixelSize}px`);
            document.documentElement.style.setProperty('--fruit-size', `${fruitPixelSize}px`);
            document.documentElement.style.setProperty('--power-pellet-size', `${powerPelletPixelSize}px`);

            const levelInfo = GAME_CONFIG.LEVELS[gameState.level];
            const displayTotalQuestions = gameState.totalQuestionsInLevel > 0 ? gameState.totalQuestionsInLevel : GAME_CONFIG.LEVELS[gameState.level].questionCount;

            appElement.innerHTML = `
                <div class="game-container">
                    <div class="level-info" style="text-align: center; margin-bottom: 1rem; padding: 0.5rem; background: hsl(var(--secondary) / 0.5); border-radius: 0.5rem;">
                        <h3 style="color: hsl(var(--accent)); margin-bottom: 0.25rem;">
                            üìö Nivel ${levelInfo.name}: ${levelInfo.description}
                        </h3>
                        <p style="font-size: 0.9rem; color: hsl(var(--muted-foreground));">
                            üéØ ${displayTotalQuestions} preguntas ‚Ä¢ üëª ${levelInfo.ghostCount} fantasma(s)
                        </p>
                    </div>
                    <div class="game-ui-bar">
                        <div class="game-stats">
                            <div class="stat-item"><span>‚ù§Ô∏è</span><span id="livesValue">${gameState.lives}</span></div>
                            <div class="stat-item"><span>‚≠ê</span><span id="scoreValue">${gameState.score}</span></div>
                            <div class="stat-item"><span>‚ùì</span><span id="questionProgressValue">0 / ${displayTotalQuestions}</span></div>
                            <div class="stat-item"><span>üéØ</span><span id="accuracyValue">0%</span></div>
                        </div>
                    </div>
                    <div class="progress-display">
                        <span>Progreso:</span>
                        <div class="progress-container"><div class="progress-bar" style="width:0%"></div></div>
                        <span id="fruitProgressValue">0 / ${gameState.totalFruits}</span>
                    </div>
                    <div id="mazeContainer" class="game-maze" style="width:${mazePixelWidth}px; height:${mazePixelHeight}px;">
                        <div id="staticContainer"></div>
                        <div id="dynamicContainer"></div>
                    </div>
                    ${isMobile ? `
                        <div class="mobile-controls">
                            <button class="up" id="upBtn" aria-label="Mover hacia arriba">‚¨ÜÔ∏è</button>
                            <button class="left" id="leftBtn" aria-label="Mover a la izquierda">‚¨ÖÔ∏è</button>
                            <button class="right" id="rightBtn" aria-label="Mover a la derecha">‚û°Ô∏è</button>
                            <button class="down" id="downBtn" aria-label="Mover hacia abajo">‚¨áÔ∏è</button>
                        </div>` : ""}
                    <p class="instructions" style="text-align: center; margin-top: 1rem; color: hsl(var(--muted-foreground)); font-size: 0.9rem;">
                        ${isMobile ? "üéÆ Usa los controles t√°ctiles para moverte" : "‚å®Ô∏è Usa las flechas del teclado para moverte"} ‚Ä¢ 
                        ‚è∏Ô∏è Usa los botones superiores para pausar/reiniciar
                    </p>
                </div>`;

            if (isMobile) {
                ["upBtn", "leftBtn", "rightBtn", "downBtn"].forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) {
                        const direction = id.replace("Btn", "");
                        btn.addEventListener("click", () => handleControlClick(direction));
                        btn.addEventListener("touchstart", (e) => { e.preventDefault(); handleControlClick(direction); });
                    }
                });
            }
            renderMaze(finalCellSize);
            updateGameUI();
            console.log("‚úÖ Interfaz de juego renderizada");
        }

        function initializeMaze() {
            console.log(`üèóÔ∏è Inicializando laberinto para nivel: ${gameState.level}`);
            const config = mazeConfigs[gameState.level] || mazeConfigs.easy;
            const levelConfig = GAME_CONFIG.LEVELS[gameState.level];

            gameState.mazeWidth = config.width;
            gameState.mazeHeight = config.height;
            gameState.walls = config.walls.map(w => ({...w}));
            gameState.fruits = config.fruits.map((pos, index) => ({ 
                id: index, 
                position: {...pos}, 
                collected: false, 
                question: null, 
                type: 'fruit' 
            }));
            gameState.fruitCollected = 0;
            gameState.totalFruits = gameState.fruits.length;
            gameState.playerPosition = { x: 1, y: 1 };
            gameState.playerDirection = "right";
            gameState.questionsAnswered = 0;
            gameState.correctAnswers = 0;

            const ghostColors = ["#FF0000", "#00FFFF", "#FFB8FF", "#FFB852"];
            const numGhosts = levelConfig.ghostCount;
            gameState.ghosts = [];
            const centerX = Math.floor(config.width / 2);
            const centerY = Math.floor(config.height / 2);

            for (let i = 0; i < numGhosts; i++) {
                let startX, startY;
                const angle = (i / numGhosts) * 2 * Math.PI;
                const radius = 1; 
                startX = Math.round(centerX + radius * Math.cos(angle));
                startY = Math.round(centerY + radius * Math.sin(angle));

                if (isWall(startX, startY) || startX < 1 || startX >= config.width - 1 || startY < 1 || startY >= config.height - 1) {
                    if(!isWall(centerX, centerY) && centerX > 0 && centerX < config.width -1 && centerY > 0 && centerY < config.height -1) {
                        startX = centerX; startY = centerY;
                    } else {
                        let found = false;
                        for(let r=1; r < Math.max(centerX, centerY); r++){ 
                            for(let di = 0; di < 8; di++){ 
                                let testX = centerX + Math.round(r * Math.cos(di * Math.PI/4));
                                let testY = centerY + Math.round(r * Math.sin(di * Math.PI/4));
                                if (!isWall(testX, testY) && testX > 0 && testX < config.width -1 && testY > 0 && testY < config.height -1) {
                                    startX = testX; startY = testY; found = true; break;
                                }
                            }
                            if(found) break;
                        }
                        if(!found) { startX = 1; startY = config.height - 2;} // Fallback
                    }
                }
                gameState.ghosts.push({ 
                    id: i, 
                    position: { x: startX, y: startY }, 
                    color: ghostColors[i % ghostColors.length], 
                    el: null, 
                    vulnerable: false, 
                    lastDirection: null 
                });
            }
            gameState.pacmanEl = null;
            console.log(`‚úÖ Laberinto inicializado: ${config.width}x${config.height}, ${numGhosts} fantasmas`);
        }

        function assignQuestionsAndPellets() {
            console.log("üé≤ Asignando preguntas y power pellets...");
            let powerPelletsAssigned = 0;
            let questionsAssigned = 0;
            const fruitIndices = Array.from({ length: gameState.fruits.length }, (_, i) => i).sort(() => Math.random() - 0.5);
            let questionPoolCopy = [...gameState.questionPool]; // Usar copia para no modificar el original aqu√≠

            fruitIndices.forEach(index => {
                const fruit = gameState.fruits[index];
                if (powerPelletsAssigned < GAME_CONFIG.POWER_PELLET_COUNT) {
                    fruit.type = 'power'; 
                    fruit.question = null; 
                    powerPelletsAssigned++;
                } else if (questionsAssigned < GAME_CONFIG.LEVELS[gameState.level].questionCount && questionPoolCopy.length > 0) {
                    const question = questionPoolCopy.pop(); 
                    if (question) { 
                        fruit.question = question; 
                        fruit.type = 'fruit'; 
                        questionsAssigned++; 
                    } else { 
                        fruit.question = null; 
                        fruit.type = 'fruit'; 
                    }
                } else {
                    fruit.question = null; 
                    fruit.type = 'fruit';
                }
            });
            gameState.totalQuestionsInLevel = questionsAssigned; // Actualizar al n√∫mero real de preguntas asignadas
            console.log(`‚úÖ Asignaci√≥n completada: ${powerPelletsAssigned} power pellets, ${questionsAssigned} preguntas con fruta.`);
        }
        
        function renderMaze(cellSize = GAME_CONFIG.CELL_SIZE) {
            const staticContainer = document.getElementById("staticContainer");
            const dynamicContainer = document.getElementById("dynamicContainer");
            if (!staticContainer || !dynamicContainer) { 
                console.error("‚ùå Contenedores de laberinto no encontrados"); 
                return; 
            }
            staticContainer.innerHTML = ""; 
            dynamicContainer.innerHTML = "";
            gameState.pacmanEl = null; 
            gameState.ghosts.forEach(g => g.el = null);

            gameState.walls.forEach(wall => {
                const el = document.createElement("div"); 
                el.className = "wall";
                el.style.left = `${wall.x * cellSize}px`; 
                el.style.top = `${wall.y * cellSize}px`;
                el.style.width = `${cellSize}px`; 
                el.style.height = `${cellSize}px`;
                staticContainer.appendChild(el);
            });

            renderMazeItems(staticContainer, cellSize);
            renderPacMan(dynamicContainer, cellSize);
            renderGhosts(dynamicContainer, cellSize);
        }

        function renderMazeItems(container, cellSize) {
            const fruitEmojis = ["üçé", "üçå", "üçá", "üçí", "üçâ", "üçì", "üçç", "ü•ù", "üçë", "üçä"];
            gameState.fruits.forEach(fruit => {
                if (!fruit.collected) {
                    const itemEl = document.createElement("div");
                    const itemSize = fruit.type === 'power' ? parseInt(document.documentElement.style.getPropertyValue('--power-pellet-size')) : parseInt(document.documentElement.style.getPropertyValue('--fruit-size'));
                    itemEl.className = fruit.type === 'power' ? 'power-pellet' : 'fruit';
                    itemEl.id = `fruit-item-${fruit.id}`; 
                    itemEl.textContent = fruit.type === 'power' ? 'üíä' : fruitEmojis[fruit.id % fruitEmojis.length];
                    itemEl.style.fontSize = `${itemSize * 0.8}px`; 
                    itemEl.style.width = `${itemSize}px`; 
                    itemEl.style.height = `${itemSize}px`;
                    itemEl.style.left = `${fruit.position.x * cellSize + (cellSize - itemSize) / 2}px`;
                    itemEl.style.top = `${fruit.position.y * cellSize + (cellSize - itemSize) / 2}px`;
                    if (fruit.question) itemEl.title = `Pregunta: ${fruit.question.tema}`;
                    else if (fruit.type === 'power') itemEl.title = "Power Pellet: +1 vida";
                    container.appendChild(itemEl);
                }
            });
        }

        function renderPacMan(container, cellSize) {
            const playerPixelSize = parseInt(document.documentElement.style.getPropertyValue('--player-size'));
            gameState.pacmanEl = document.createElement("div");
            gameState.pacmanEl.className = "pacman-player";
            gameState.pacmanEl.setAttribute('data-direction', gameState.playerDirection);
            
            const mouthEl = document.createElement("div"); 
            mouthEl.className = "pacman-mouth";
            gameState.pacmanEl.appendChild(mouthEl);
            
            gameState.pacmanEl.style.left = `${gameState.playerPosition.x * cellSize + (cellSize - playerPixelSize) / 2}px`;
            gameState.pacmanEl.style.top = `${gameState.playerPosition.y * cellSize + (cellSize - playerPixelSize) / 2}px`;
            container.appendChild(gameState.pacmanEl);
        }

        function renderGhosts(container, cellSize) {
            const ghostPixelSize = parseInt(document.documentElement.style.getPropertyValue('--ghost-size'));
            gameState.ghosts.forEach(ghost => {
                ghost.el = document.createElement("div"); 
                ghost.el.className = "ghost";
                ghost.el.style.backgroundColor = ghost.vulnerable ? "#0066FF" : ghost.color;
                ghost.el.setAttribute('data-look', 'right'); // Default look

                const eyesContainer = document.createElement("div"); 
                eyesContainer.className = 'ghost-eyes';
                const eyeLeft = document.createElement("div"); 
                eyeLeft.className = "ghost-eye";
                const pupilLeft = document.createElement("div"); 
                pupilLeft.className = "ghost-pupil"; 
                eyeLeft.appendChild(pupilLeft);
                const eyeRight = document.createElement("div"); 
                eyeRight.className = "ghost-eye";
                const pupilRight = document.createElement("div"); 
                pupilRight.className = "ghost-pupil"; 
                eyeRight.appendChild(pupilRight);
                eyesContainer.appendChild(eyeLeft); 
                eyesContainer.appendChild(eyeRight); 
                ghost.el.appendChild(eyesContainer);

                ghost.el.style.left = `${ghost.position.x * cellSize + (cellSize - ghostPixelSize) / 2}px`;
                ghost.el.style.top = `${ghost.position.y * cellSize + (cellSize - ghostPixelSize) / 2}px`;
                container.appendChild(ghost.el);
            });
        }

        function attachEventHandlers() {
            document.removeEventListener("keydown", handleKeyDown); // Evitar duplicados
            document.addEventListener("keydown", handleKeyDown);
        }

        function handleKeyDown(e) {
            if (!gameState.gameStarted || gameState.paused || gameState.gameCompleted || 
                questionDialog.style.display !== 'none' || 
                completionDialog.style.display !== 'none' || 
                helpDialog.style.display !== 'none') return;

            if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
                e.preventDefault();
                const directionMap = { "ArrowUp": "up", "ArrowDown": "down", "ArrowLeft": "left", "ArrowRight": "right" };
                movePlayer(directionMap[e.key]);
            }
        }

        function handleControlClick(direction) {
            if (!gameState.gameStarted || gameState.paused || gameState.gameCompleted || 
                questionDialog.style.display !== 'none' || 
                completionDialog.style.display !== 'none' || 
                helpDialog.style.display !== 'none') return;
            movePlayer(direction);
        }

        function movePlayer(direction) {
            let newPos = { ...gameState.playerPosition };
            if (direction === "up") newPos.y--;
            else if (direction === "down") newPos.y++;
            else if (direction === "left") newPos.x--;
            else if (direction === "right") newPos.x++;

            if (newPos.x >= 0 && newPos.x < gameState.mazeWidth && 
                newPos.y >= 0 && newPos.y < gameState.mazeHeight && 
                !isWall(newPos.x, newPos.y)) {
                gameState.playerPosition = newPos;
                gameState.playerDirection = direction;
                soundManager.play('chomp', 'C3', '32n');
                checkItemCollection();
                checkGhostCollision();
                updateDynamicElements();
                checkWinCondition();
            } else {
                // A√∫n actualiza la direcci√≥n si el jugador intenta moverse contra una pared
                gameState.playerDirection = direction;
                updateDynamicElements();
            }
        }

        function isWall(x, y) {
            return gameState.walls.some(w => w.x === x && w.y === y);
        }

        function checkItemCollection() {
            const playerPos = gameState.playerPosition;
            const itemIndex = gameState.fruits.findIndex(f => !f.collected && f.position.x === playerPos.x && f.position.y === playerPos.y);

            if (itemIndex !== -1) {
                const collectedItem = gameState.fruits[itemIndex];
                collectedItem.collected = true;
                gameState.fruitCollected++;

                const itemEl = document.getElementById(`fruit-item-${collectedItem.id}`);
                if (itemEl) itemEl.remove();

                if (collectedItem.type === 'power') {
                    handlePowerPelletCollection();
                } else if (collectedItem.question) {
                    handleQuestionFruit(collectedItem.question);
                } else {
                    // Fruta normal sin pregunta (si alguna qued√≥ as√≠)
                    gameState.score += GAME_CONFIG.POINTS.FRUIT_BASIC;
                    soundManager.play('fruitCollect', 'E5', '16n');
                    showToast("¬°Fruta!", `+${GAME_CONFIG.POINTS.FRUIT_BASIC} puntos`);
                    updateGameUI();
                }
            }
        }

        function handlePowerPelletCollection() {
            soundManager.play('powerPelletCollect', 'G5', '8n');
            if (gameState.lives < GAME_CONFIG.MAX_LIVES) {
                gameState.lives++;
                showToast("¬°Vida Extra!", `‚ù§Ô∏è Vidas: ${gameState.lives}`, "success");
            } else {
                showToast("¬°Power Pellet!", "Ya tienes el m√°ximo de vidas");
            }
            makeGhostsVulnerable();
            updateGameUI();
        }

        function makeGhostsVulnerable() {
            gameState.ghostsVulnerable = true;
            gameState.powerPelletActive = true;
            soundManager.startLoop('powerPelletActiveLoop');

            gameState.ghosts.forEach(ghost => {
                ghost.vulnerable = true;
                if (ghost.el) { 
                    ghost.el.classList.add("vulnerable");
                    ghost.el.classList.remove("vulnerable-ending");
                }
            });

            if (gameState.vulnerableGhostsTimer) clearTimeout(gameState.vulnerableGhostsTimer);
            gameState.vulnerableGhostsTimer = setTimeout(() => {
                if (gameState.gameCompleted) return; // No revertir si el juego ya termin√≥
                gameState.ghostsVulnerable = false;
                gameState.powerPelletActive = false;
                soundManager.stopLoop('powerPelletActiveLoop');
                gameState.ghosts.forEach(ghost => {
                    ghost.vulnerable = false;
                    if (ghost.el) { 
                        ghost.el.style.backgroundColor = ghost.color; // Restaurar color original
                        ghost.el.classList.remove("vulnerable", "vulnerable-ending");
                    }
                });
                showToast("‚ö†Ô∏è Advertencia", "Los fantasmas ya no son vulnerables", "destructive");
            }, GAME_CONFIG.VULNERABLE_TIME);

            // Timer para el parpadeo de advertencia
            setTimeout(() => {
                if (gameState.gameCompleted || !gameState.ghostsVulnerable) return;
                gameState.ghosts.forEach(ghost => { 
                    if (ghost.el && ghost.vulnerable) { 
                        ghost.el.classList.remove("vulnerable");
                        ghost.el.classList.add("vulnerable-ending");
                    }
                });
                showToast("‚è∞ ¬°Cuidado!", "El efecto del power pellet est√° terminando", "destructive");
            }, GAME_CONFIG.VULNERABLE_TIME - 2000); // 2 segundos antes de que termine

            showToast("üíä ¬°Power Activo!", "¬°Ahora puedes comer fantasmas!", "success");
        }

        function handleQuestionFruit(question) {
            soundManager.play('fruitCollect', 'A4', '16n');
            gameState.currentQuestion = question;
            gameState.questionStartTime = Date.now();
            showQuestionDialog();
        }

        function showToast(title, message, type = "default") {
            const toast = document.createElement("div");
            toast.className = `toast toast-${type}`;
            toast.innerHTML = `<div class="toast-title">${title}</div><div class="toast-description">${message.replace(/\n/g, '<br>')}</div>`;
            toastContainer.appendChild(toast);
            setTimeout(() => { // Animar entrada
                toast.style.opacity = "1";
                toast.style.transform = "translateX(0)";
            }, 10);
            setTimeout(() => { // Animar salida
                toast.style.opacity = "0";
                toast.style.transform = "translateX(100%)";
                setTimeout(() => { if (toast.parentNode) toast.remove(); }, 300); // Eliminar del DOM
            }, type === "success" || type === "destructive" ? 5000 : 3000); // Duraci√≥n m√°s larga para mensajes importantes
        }

        function showQuestionDialog() {
            if (!gameState.currentQuestion) { 
                console.error("‚ùå No hay pregunta actual para mostrar."); 
                return; 
            }
            gameState.paused = true; // Pausar el juego
            if (gameState.ghostMovementInterval) { 
                clearInterval(gameState.ghostMovementInterval); 
                gameState.ghostMovementInterval = null; 
            }
            if(gameState.powerPelletActive) soundManager.stopLoop('powerPelletActiveLoop'); // Detener sonido de power pellet si est√° activo

            globalPauseBtn.textContent = "‚è∏Ô∏è Pausado";
            globalPauseBtn.disabled = true;

            const displayTotalQ = gameState.totalQuestionsInLevel > 0 ? gameState.totalQuestionsInLevel : GAME_CONFIG.LEVELS[gameState.level].questionCount;
            
            questionDialog.innerHTML = `
                <div class="dialog-content" style="max-width: 600px;">
                    <div class="dialog-header">
                        <h2 class="dialog-title" style="color: var(--question-title-color); font-size: 1.8rem;">üß† Pregunta de ${gameState.currentQuestion.tema}</h2>
                        <p class="dialog-description">Pregunta ${gameState.questionsAnswered + 1} de ${displayTotalQ} ‚Ä¢ Nivel: ${GAME_CONFIG.LEVELS[gameState.level].name}</p>
                    </div>
                    <div class="dialog-body">
                        <div id="questionTextDialog" style="font-size: 1.2rem; font-weight: 500; margin-bottom: 1.5rem; text-align: center; line-height: 1.5; padding: 1rem; background: hsl(var(--secondary) / 0.3); border-radius: 0.5rem; border-left: 4px solid hsl(var(--accent));">${gameState.currentQuestion.question}</div>
                        <div class="options-container" id="optionsContainerDialog">
                            </div>
                        <div id="questionTimer" style="text-align: center; margin-top: 1rem; font-size: 0.9rem; color: hsl(var(--muted-foreground));">‚è±Ô∏è Tiempo: <span id="timerValue">0</span>s</div>
                    </div>
                </div>`;

            const optionsContainerDialog = document.getElementById("optionsContainerDialog");
            const shuffledOptions = [...gameState.currentQuestion.opciones].sort(() => Math.random() - 0.5);
            shuffledOptions.forEach((opcion, index) => {
                const btn = document.createElement("button");
                btn.className = "option-btn";
                btn.innerHTML = `<span style="font-weight: bold; color: hsl(var(--accent)); margin-right: 0.5rem;">${String.fromCharCode(65 + index)})</span> ${opcion}`;
                btn.addEventListener("click", () => {
                    soundManager.play('buttonClick', 'C5', '16n');
                    handleQuestionResponse(opcion);
                });
                optionsContainerDialog.appendChild(btn);
            });
            questionDialog.style.display = 'flex';
            startQuestionTimer();
        }

        function startQuestionTimer() {
            const timerValueEl = document.getElementById("timerValue");
            if (!timerValueEl) return;
            const startTime = Date.now();
            if (gameState.questionTimerInterval) clearInterval(gameState.questionTimerInterval); // Limpiar anterior
            gameState.questionTimerInterval = setInterval(() => {
                if (questionDialog.style.display === 'none' || gameState.gameCompleted) {
                    clearInterval(gameState.questionTimerInterval);
                    gameState.questionTimerInterval = null;
                    return;
                }
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                timerValueEl.textContent = elapsed;
                if (elapsed > 20) timerValueEl.style.color = "hsl(var(--destructive))";
                else if (elapsed > 10) timerValueEl.style.color = "orange";
                else timerValueEl.style.color = "hsl(var(--muted-foreground))";
            }, 1000);
        }

        function handleQuestionResponse(selectedOption) {
            if (!gameState.currentQuestion) return;
            if (gameState.questionTimerInterval) { 
                clearInterval(gameState.questionTimerInterval); 
                gameState.questionTimerInterval = null; 
            }

            const correctAnswer = gameState.currentQuestion.respuestaCorrecta.trim();
            const userAnswer = selectedOption.trim();
            const isCorrect = userAnswer === correctAnswer;
            const responseTime = Date.now() - gameState.questionStartTime;
            const isQuickResponse = responseTime < 10000; // 10 segundos para bonus

            gameState.questionsAnswered++;
            if (isCorrect) { 
                gameState.correctAnswers++; 
                soundManager.play('correctAnswer', 'G4', '8n');
            } else { 
                soundManager.play('incorrectAnswer', 'C3', '8n');
            }

            let points = 0;
            if (isCorrect) {
                points = GAME_CONFIG.POINTS[`QUESTION_${gameState.level.toUpperCase()}`] || GAME_CONFIG.POINTS.QUESTION_EASY;
                if (isQuickResponse) points += GAME_CONFIG.POINTS.SPEED_BONUS;
                gameState.score += points;
                const bonusText = isQuickResponse ? ` (+${GAME_CONFIG.POINTS.SPEED_BONUS} bonus)` : "";
                showToast("üéâ ¬°Correcto!", `+${points} puntos${bonusText}${gameState.currentQuestion.explicacion ? '\nüí° ' + gameState.currentQuestion.explicacion : ''}`, "success");
            } else {
                gameState.lives--;
                showToast("‚ùå Incorrecto", `Respuesta: ${correctAnswer}\n${gameState.currentQuestion.explicacion ? 'üí° ' + gameState.currentQuestion.explicacion : ''}\nüíî Vidas: ${gameState.lives}`, "destructive");
                if (gameState.lives <= 0) {
                    questionDialog.style.display = 'none';
                    endGame(false);
                    return;
                }
            }

            gameState.currentQuestion = null;
            questionDialog.style.display = 'none';

            // Retrasar la reanudaci√≥n para que el jugador pueda leer el toast
            setTimeout(() => {
                if(gameState.gameCompleted) return; // No reanudar si el juego ya termin√≥ (ej. por perder la √∫ltima vida)
                
                gameState.paused = false;
                globalPauseBtn.disabled = false;
                globalPauseBtn.textContent = "‚è∏Ô∏è Pausar";
                
                if (!gameState.gameCompleted && !gameState.ghostMovementInterval) { // Reanudar movimiento de fantasmas
                    const ghostSpeed = GAME_CONFIG.LEVELS[gameState.level].ghostSpeed;
                    gameState.ghostMovementInterval = setInterval(moveGhosts, ghostSpeed);
                }
                if(gameState.powerPelletActive && gameState.ghostsVulnerable) soundManager.startLoop('powerPelletActiveLoop');

                updateGameUI();
            }, 1500); // 1.5 segundos de retraso
        }

        function moveGhosts() {
            if (!gameState.gameStarted || gameState.gameCompleted || gameState.paused || 
                (questionDialog && questionDialog.style.display !== 'none')) return;
            if (!gameState.ghosts.length) return;

            gameState.ghosts.forEach(ghost => moveGhost(ghost));
            checkGhostCollision(); // Verificar colisi√≥n despu√©s de mover todos los fantasmas
            updateDynamicElements(); // Actualizar la UI
        }

        function moveGhost(ghost) {
            const directions = [
                { dx: 1, dy: 0, name: "right" }, 
                { dx: -1, dy: 0, name: "left" },
                { dx: 0, dy: 1, name: "down" },
                { dx: 0, dy: -1, name: "up" }
            ];
            let validMoves = [];
            let bestMove = null;
            let distanceMetric = ghost.vulnerable ? -Infinity : Infinity; // Si es vulnerable, quiere alejarse; si no, acercarse

            const dxPlayer = gameState.playerPosition.x - ghost.position.x;
            const dyPlayer = gameState.playerPosition.y - ghost.position.y;

            directions.forEach(dir => {
                const newX = ghost.position.x + dir.dx;
                const newY = ghost.position.y + dir.dy;
                if (newX >= 0 && newX < gameState.mazeWidth && 
                    newY >= 0 && newY < gameState.mazeHeight && 
                    !isWall(newX, newY)) {
                    validMoves.push(dir);
                    const distToPlayer = Math.sqrt(Math.pow(gameState.playerPosition.x - newX, 2) + Math.pow(gameState.playerPosition.y - newY, 2));
                    if (ghost.vulnerable) { // Huir
                        if (distToPlayer > distanceMetric) { distanceMetric = distToPlayer; bestMove = dir; }
                    } else { // Perseguir
                        if (distToPlayer < distanceMetric) { distanceMetric = distToPlayer; bestMove = dir; }
                    }
                }
            });

            if (validMoves.length === 0) return; // No hay movimientos v√°lidos

            let chosenMove = null;
            if (ghost.vulnerable) { // L√≥gica de huida: 80% de probabilidad de tomar el mejor movimiento de huida
                chosenMove = (bestMove && Math.random() < 0.8) ? bestMove : validMoves[Math.floor(Math.random() * validMoves.length)];
            } else { // L√≥gica de persecuci√≥n
                const chasePerc = getLevelChasePercentage(); // Probabilidad de tomar el mejor movimiento
                if (bestMove && Math.random() < chasePerc) {
                    chosenMove = bestMove;
                } else { // Movimiento aleatorio (evitando revertir direcci√≥n si es posible)
                    const nonReversingMoves = validMoves.filter(m => 
                        !(ghost.lastDirection && m.dx === -ghost.lastDirection.dx && m.dy === -ghost.lastDirection.dy)
                    );
                    const movesToPickFrom = nonReversingMoves.length > 0 ? nonReversingMoves : validMoves;
                    chosenMove = movesToPickFrom[Math.floor(Math.random() * movesToPickFrom.length)];
                }
            }
            
            if (chosenMove) {
                ghost.position.x += chosenMove.dx;
                ghost.position.y += chosenMove.dy;
                ghost.lastDirection = chosenMove; // Guardar la √∫ltima direcci√≥n
                updateGhostLook(ghost, dxPlayer, dyPlayer); // Actualizar la apariencia del fantasma
            }
        }

        function getLevelChasePercentage() {
            const percentages = {'easy': 0.4, 'medium': 0.6, 'hard': 0.75, 'expert': 0.85};
            return percentages[gameState.level] || 0.5; // Default
        }

        function updateGhostLook(ghost, dxPlayer, dyPlayer) {
            if (!ghost.el) return;
            let lookDir = "right"; // Default
            // Determinar la direcci√≥n principal del jugador relativo al fantasma
            if (dxPlayer === 0 && dyPlayer === 0) { // Si est√°n en la misma casilla, usar la √∫ltima direcci√≥n del fantasma
                if(ghost.lastDirection) lookDir = ghost.lastDirection.name;
            } else if (Math.abs(dxPlayer) > Math.abs(dyPlayer)) {
                lookDir = dxPlayer > 0 ? "right" : "left";
            } else {
                lookDir = dyPlayer > 0 ? "down" : "up";
            }
            ghost.el.setAttribute('data-look', lookDir);
        }

        function checkGhostCollision() {
            if (gameState.paused || gameState.gameCompleted) return;
            let collisionOccurred = false;
            let ghostEaten = null;

            gameState.ghosts.forEach(ghost => {
                if (ghost.position.x === gameState.playerPosition.x && ghost.position.y === gameState.playerPosition.y) {
                    if (ghost.vulnerable && gameState.ghostsVulnerable) {
                        ghostEaten = ghost; // Marcar para comer
                    } else {
                        collisionOccurred = true; // Colisi√≥n normal
                    }
                }
            });

            if (ghostEaten) {
                handleGhostEaten(ghostEaten);
            } else if (collisionOccurred) {
                handlePlayerCaught();
            }
        }

        function handleGhostEaten(ghost) {
            soundManager.play('ghostEaten', 'A3', '4n');
            gameState.score += GAME_CONFIG.POINTS.GHOST_EATEN;
            
            // Reposicionar fantasma (ej. al centro o a un punto de inicio)
            const centerX = Math.floor(gameState.mazeWidth / 2);
            const centerY = Math.floor(gameState.mazeHeight / 2);
            ghost.position = { x: centerX, y: centerY }; 
            ghost.vulnerable = false; // Ya no es vulnerable
            if(ghost.el){
                ghost.el.style.backgroundColor = ghost.color; // Restaurar color
                ghost.el.classList.remove("vulnerable", "vulnerable-ending");
            }
            showToast("üëª ¬°Fantasma Comido!", `+${GAME_CONFIG.POINTS.GHOST_EATEN} puntos`, "success");
            updateGameUI();
        }

        function handlePlayerCaught() {
            soundManager.play('playerCaught', null, '0.5s'); // NoiseSynth no usa nota
            gameState.lives--;
            showToast("üëª ¬°Atrapado!", `Vidas restantes: ${gameState.lives}`, "destructive");

            if (gameState.lives <= 0) {
                endGame(false); // Juego terminado
            } else {
                // Reposicionar jugador al inicio
                gameState.playerPosition = { x: 1, y: 1 }; 
                updateDynamicElements(); // Actualizar posici√≥n en UI
            }
            updateGameUI();
        }

        function updateDynamicElements() {
            const cellSize = parseInt(document.documentElement.style.getPropertyValue('--cell-size'));
            const playerSize = parseInt(document.documentElement.style.getPropertyValue('--player-size'));
            const ghostSize = parseInt(document.documentElement.style.getPropertyValue('--ghost-size'));

            if(gameState.pacmanEl){
                gameState.pacmanEl.style.left = `${gameState.playerPosition.x * cellSize + (cellSize - playerSize) / 2}px`;
                gameState.pacmanEl.style.top = `${gameState.playerPosition.y * cellSize + (cellSize - playerSize) / 2}px`;
                gameState.pacmanEl.setAttribute('data-direction', gameState.playerDirection);
            }

            gameState.ghosts.forEach(ghost => {
                if(ghost.el){
                    ghost.el.style.left = `${ghost.position.x * cellSize + (cellSize - ghostSize) / 2}px`;
                    ghost.el.style.top = `${ghost.position.y * cellSize + (cellSize - ghostSize) / 2}px`;
                    // Actualizar estilo si es vulnerable o no
                    if(!ghost.vulnerable){
                        ghost.el.style.backgroundColor = ghost.color;
                        ghost.el.classList.remove("vulnerable", "vulnerable-ending");
                    } else if (!ghost.el.classList.contains('vulnerable-ending')) { // Si es vulnerable pero no parpadeando
                        ghost.el.classList.add('vulnerable');
                    }
                }
            });
            updateGameUI(); // Actualizar estad√≠sticas
        }

        function updateGameUI() {
            const livesEl = document.getElementById("livesValue");
            if(livesEl) livesEl.textContent = gameState.lives;
            const scoreEl = document.getElementById("scoreValue");
            if(scoreEl) scoreEl.textContent = gameState.score;
            
            updateQuestionProgressDisplay();
            updateAccuracyDisplay();

            const progressBarEl = document.querySelector(".progress-bar");
            if(progressBarEl){
                const percentage = gameState.totalFruits > 0 ? (gameState.fruitCollected / gameState.totalFruits) * 100 : 0;
                progressBarEl.style.width = `${percentage}%`;
            }
            const fruitProgressEl = document.getElementById("fruitProgressValue");
            if(fruitProgressEl) fruitProgressEl.textContent = `${gameState.fruitCollected} / ${gameState.totalFruits}`;
        }

        function updateQuestionProgressDisplay() {
            const displayEl = document.getElementById("questionProgressValue");
            if (displayEl) {
                const answeredToShow = Math.min(gameState.questionsAnswered, gameState.totalQuestionsInLevel);
                const totalQ = gameState.totalQuestionsInLevel > 0 ? gameState.totalQuestionsInLevel : (GAME_CONFIG.LEVELS[gameState.level] ? GAME_CONFIG.LEVELS[gameState.level].questionCount : "-"); 
                displayEl.textContent = `${answeredToShow} / ${totalQ}`;
            }
        }

        function updateAccuracyDisplay() {
            const accuracyEl = document.getElementById("accuracyValue");
            if(accuracyEl){
                const accuracy = gameState.questionsAnswered > 0 ? Math.round((gameState.correctAnswers / gameState.questionsAnswered) * 100) : 0;
                accuracyEl.textContent = `${accuracy}%`;
                if(accuracy >= 80) accuracyEl.style.color = "hsl(var(--accent))";
                else if(accuracy >= 60) accuracyEl.style.color = "orange";
                else accuracyEl.style.color = "hsl(var(--destructive))";
            }
        }

        function checkWinCondition() {
            if (!gameState.gameCompleted && gameState.fruitCollected === gameState.totalFruits && gameState.totalFruits > 0) {
                endGame(true); // Victoria
            }
        }

        function endGame(victory) {
            if (gameState.gameCompleted) return; // Evitar m√∫ltiples llamadas
            console.log(`üéÆ Finalizando juego - Victoria: ${victory}`);

            if (victory) soundManager.play('gameWin','C5','1s');
            else soundManager.play('gameOver','C2','1s');
            
            gameState.powerPelletActive = false; // Asegurarse de detener el loop de power pellet
            soundManager.stopLoop('powerPelletActiveLoop');

            gameState.gameCompleted = true;
            gameState.paused = true; // Pausar efectivamente el juego

            if(gameState.ghostMovementInterval){ clearInterval(gameState.ghostMovementInterval); gameState.ghostMovementInterval = null; }
            if(gameState.vulnerableGhostsTimer){ clearTimeout(gameState.vulnerableGhostsTimer); gameState.vulnerableGhostsTimer = null; }
            if(gameState.questionTimerInterval){ clearInterval(gameState.questionTimerInterval); gameState.questionTimerInterval = null; }
            
            questionDialog.style.display = 'none'; // Ocultar di√°logo de pregunta si est√° visible
            gameState.finalGrade = calculateFinalGrade();
            
            globalPauseBtn.disabled = true;
            globalPauseBtn.textContent = "üèÅ Finalizado";
            
            setTimeout(() => showCompletionDialog(victory), 500); // Mostrar di√°logo de finalizaci√≥n
        }

        function showCompletionDialog(victory) {
            const finalMessage = getFinalMessage(gameState.finalGrade);
            const levelInfo = GAME_CONFIG.LEVELS[gameState.level];
            const accuracy = gameState.questionsAnswered > 0 ? ((gameState.correctAnswers / gameState.questionsAnswered) * 100).toFixed(1) : "0.0";
            const completionPercentage = gameState.totalFruits > 0 ? ((gameState.fruitCollected / gameState.totalFruits) * 100).toFixed(1) : "0.0";
            const totalQuestionsDisplay = gameState.totalQuestionsInLevel > 0 ? gameState.totalQuestionsInLevel : (GAME_CONFIG.LEVELS[gameState.level] ? GAME_CONFIG.LEVELS[gameState.level].questionCount : "-");
            const questionsAnsweredDisplay = gameState.questionsAnswered > 0 ? gameState.questionsAnswered : "0";

            const title = victory ? "üéâ ¬°Nivel Completado!" : "üíî Juego Terminado";
            const description = victory ? "¬°Felicitaciones! Has demostrado un excelente conocimiento de f√≠sica." : "No te desanimes. La f√≠sica requiere pr√°ctica y perseverancia.";

            completionDialog.innerHTML = `
                <div class="dialog-content" style="max-width: 650px;">
                    <div class="dialog-header">
                        <h2 class="dialog-title" style="font-size: 2rem; margin-bottom: 1rem;">${title}</h2>
                        <p class="dialog-description" style="font-size: 1.1rem;">${description}</p>
                    </div>
                    <div class="dialog-body" style="text-align: left;">
                        <div style="background: hsl(var(--secondary) / 0.5); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1.5rem; text-align: center;">
                            <h3 style="color: hsl(var(--accent)); margin-bottom: 0.5rem;">üìö Nivel: ${levelInfo.name}</h3>
                            <p style="font-size: 0.9rem; color: hsl(var(--muted-foreground));">${levelInfo.description}</p>
                        </div>
                        <div style="text-align: center; margin-bottom: 2rem;">
                            <div style="font-size: 3rem; font-weight: bold; color: ${getGradeColor(gameState.finalGrade)}; margin-bottom: 0.5rem;">
                                ${parseFloat(gameState.finalGrade).toFixed(1)} / 5.0
                            </div>
                            <div style="font-size: 1.2rem; color: hsl(var(--muted-foreground));">${getGradeLabel(gameState.finalGrade)}</div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 1.5rem;">
                            <div class="completion-stat"><span>üìä Puntuaci√≥n:</span><span style="color: hsl(var(--accent)); font-weight: bold;">${gameState.score} ‚≠ê</span></div>
                            <div class="completion-stat"><span>‚ù§Ô∏è Vidas:</span><span style="color: ${gameState.lives > Math.floor(GAME_CONFIG.MAX_LIVES * 0.3) ? 'hsl(var(--accent))' : 'hsl(var(--destructive))'}; font-weight: bold;">${gameState.lives}/${GAME_CONFIG.MAX_LIVES}</span></div>
                            <div class="completion-stat"><span>‚ùì Preguntas:</span><span style="color: hsl(var(--primary)); font-weight: bold;">${questionsAnsweredDisplay}/${totalQuestionsDisplay}</span></div>
                            <div class="completion-stat"><span>üéØ Precisi√≥n:</span><span style="color: ${parseFloat(accuracy) >= 80 ? 'hsl(var(--accent))' : parseFloat(accuracy) >= 60 ? 'orange' : 'hsl(var(--destructive))'}; font-weight: bold;">${accuracy}% (${gameState.correctAnswers}/${questionsAnsweredDisplay})</span></div>
                            <div class="completion-stat"><span>üçé Frutas:</span><span style="color: hsl(var(--primary)); font-weight: bold;">${completionPercentage}% (${gameState.fruitCollected}/${gameState.totalFruits})</span></div>
                            <div class="completion-stat"><span>üëª Fantasmas:</span><span style="color: hsl(var(--muted-foreground)); font-weight: bold;">${levelInfo.ghostCount}</span></div>
                        </div>
                        <div style="background: hsl(var(--secondary) / 0.3); padding: 1rem; border-radius: 0.5rem; margin-bottom: 1.5rem;">
                            <h4 style="color: hsl(var(--accent)); margin-bottom: 0.75rem;">üìà An√°lisis:</h4>
                            ${generatePerformanceAnalysis()}
                        </div>
                        <div style="text-align: center; padding: 1.5rem; background: linear-gradient(135deg, hsl(var(--primary) / 0.1), hsl(var(--accent) / 0.1)); border-radius: 0.75rem; border-left: 4px solid hsl(var(--accent));">
                            <p style="font-size: 1.1rem; font-weight: 500; line-height: 1.5; color: hsl(var(--foreground));">${finalMessage}</p>
                        </div>
                    </div>
                    <div class="dialog-footer" style="display: flex; gap: 1rem; justify-content: center; margin-top: 2rem;">
                        <button id="playAgainBtnDialog" class="button button-primary" style="min-width: 150px;">üîÑ Jugar de Nuevo</button>
                        <button id="changeLevelBtnDialog" class="button button-secondary" style="min-width: 150px;">üìö Cambiar Nivel</button>
                    </div>
                </div>`;
            completionDialog.style.display = 'flex';
            document.getElementById("playAgainBtnDialog").addEventListener("click", () => { 
                soundManager.play('buttonClick', 'E5', '16n'); 
                restartCurrentLevel(); 
            });
            document.getElementById("changeLevelBtnDialog").addEventListener("click", () => { 
                soundManager.play('buttonClick', 'D5', '16n'); 
                completionDialog.style.display = 'none'; 
                resetGame(); 
            });
        }

        function getGradeColor(grade) { 
            grade = parseFloat(grade); 
            if(grade >= 4.5) return "hsl(var(--accent))"; 
            if(grade >= 4.0) return "#2ecc71"; 
            if(grade >= 3.0) return "#3498db"; 
            if(grade >= 2.0) return "orange"; 
            return "hsl(var(--destructive))";
        }

        function getGradeLabel(grade) { 
            grade = parseFloat(grade); 
            if(grade >= 4.7) return "üèÜ SOBRESALIENTE"; 
            if(grade >= 4.0) return "üåü EXCELENTE"; 
            if(grade >= 3.5) return "üëç MUY BUENO"; 
            if(grade >= 3.0) return "‚úÖ BUENO"; 
            if(grade >= 2.0) return "üìö ACEPTABLE"; 
            return "üí™ NECESITA MEJORAR";
        }

        function generatePerformanceAnalysis() {
            const accuracy = gameState.questionsAnswered > 0 ? (gameState.correctAnswers / gameState.questionsAnswered) * 100 : 0;
            const livesKeptPercentage = GAME_CONFIG.MAX_LIVES > 0 ? (gameState.lives / GAME_CONFIG.MAX_LIVES) * 100 : 0;
            const completion = gameState.totalFruits > 0 ? (gameState.fruitCollected / gameState.totalFruits) * 100 : 0;
            let analysis = [];

            if (gameState.questionsAnswered > 0) {
                if (accuracy >= 90) analysis.push("üéØ <strong>Excelente precisi√≥n</strong> - Dominas muy bien los conceptos.");
                else if (accuracy >= 70) analysis.push("üëç <strong>Buena precisi√≥n</strong> - Entiendes bien la mayor√≠a de conceptos.");
                else if (accuracy >= 50) analysis.push("üìö <strong>Precisi√≥n moderada</strong> - Revisa algunos conceptos b√°sicos.");
                else analysis.push("üí° <strong>Necesitas m√°s pr√°ctica</strong> - Repasa los fundamentos te√≥ricos.");
            } else if (gameState.totalQuestionsInLevel > 0) {
                 analysis.push("ü§î No se respondieron preguntas. ¬°Intenta recolectar m√°s frutas con preguntas la pr√≥xima vez!");
            } else {
                 analysis.push("ü§∑ No hubo preguntas en este nivel para evaluar la precisi√≥n.");
            }

            if (livesKeptPercentage >= 75) analysis.push("üõ°Ô∏è <strong>Excelente estrategia</strong> - Navegaste el laberinto con habilidad.");
            else if (livesKeptPercentage >= 50) analysis.push("‚öñÔ∏è <strong>Estrategia balanceada</strong> - Buena gesti√≥n de riesgos.");
            else analysis.push("‚ö° <strong>Juego arriesgado</strong> - Observa mejor los patrones de los fantasmas.");

            if (gameState.totalFruits > 0) {
                if (completion === 100) analysis.push("üèÅ <strong>Completitud total</strong> - ¬°Recolectaste todo!");
                else if (completion >= 80) analysis.push("üéØ <strong>Casi completo</strong> - Muy buen progreso.");
                else if (completion > 0) analysis.push("üèÉ Sigue explorando para encontrar todas las frutas.");
                else analysis.push("üçé No se recolectaron frutas.");
            } else {
                analysis.push("üåü No hab√≠a frutas para recolectar en este laberinto.");
            }
            return analysis.map(item => `<div style="margin-bottom: 0.5rem;">${item}</div>`).join('');
        }
        
        function restartCurrentLevel() { 
            completionDialog.style.display = 'none'; 
            startGame(); 
        }

        function resetGame() {
            soundManager.play('buttonClick','C4','16n');
            gameState.powerPelletActive = false; // Detener loop de power pellet
            soundManager.stopLoop('powerPelletActiveLoop');

            if(gameState.ghostMovementInterval) clearInterval(gameState.ghostMovementInterval); 
            gameState.ghostMovementInterval = null;
            if(gameState.vulnerableGhostsTimer) clearTimeout(gameState.vulnerableGhostsTimer); 
            gameState.vulnerableGhostsTimer = null;
            if(gameState.questionTimerInterval) clearInterval(gameState.questionTimerInterval); 
            gameState.questionTimerInterval = null;

            // Resetear el estado del juego
            gameState.gameStarted = false;
            gameState.gameCompleted = false;
            gameState.paused = false;
            gameState.score = 0;
            gameState.lives = GAME_CONFIG.MAX_LIVES;
            gameState.fruitCollected = 0;
            gameState.totalFruits = 0;
            gameState.questionsAnswered = 0;
            gameState.correctAnswers = 0;
            gameState.totalQuestionsInLevel = 0;
            gameState.ghosts = [];
            gameState.currentQuestion = null;
            gameState.questionPool = [];
            gameState.usedQuestions = [];
            gameState.ghostsVulnerable = false;
            gameState.questionStartTime = null;
            gameState.finalGrade = 0;

            // Ocultar di√°logos
            completionDialog.style.display = 'none';
            questionDialog.style.display = 'none';
            helpDialog.style.display = 'none';

            globalPauseBtn.textContent = "‚è∏Ô∏è Pausar";
            globalPauseBtn.disabled = true; // Deshabilitar hasta que comience un nuevo juego

            renderApp(); // Volver al selector de nivel
            console.log("‚úÖ Juego reseteado");
        }

        function togglePause() {
            if (gameState.gameCompleted || !gameState.gameStarted || 
                (questionDialog && questionDialog.style.display !== 'none') ||
                (helpDialog && helpDialog.style.display !== 'none') ||
                (completionDialog && completionDialog.style.display !== 'none')) return;

            soundManager.play('buttonClick','D4','16n');
            if (!gameState.paused) {
                gameState.paused = true;
                if(gameState.ghostMovementInterval){ clearInterval(gameState.ghostMovementInterval); gameState.ghostMovementInterval = null; }
                if(gameState.powerPelletActive) soundManager.stopLoop('powerPelletActiveLoop');
                globalPauseBtn.textContent = "‚ñ∂Ô∏è Reanudar";
                showToast("‚è∏Ô∏è Pausado", "El juego est√° en pausa");
            } else {
                gameState.paused = false;
                if(!gameState.gameCompleted){ // Solo reanudar si el juego no ha terminado
                    const ghostSpeed = GAME_CONFIG.LEVELS[gameState.level].ghostSpeed;
                    gameState.ghostMovementInterval = setInterval(moveGhosts, ghostSpeed);
                    if(gameState.powerPelletActive && gameState.ghostsVulnerable) soundManager.startLoop('powerPelletActiveLoop');
                }
                globalPauseBtn.textContent = "‚è∏Ô∏è Pausar";
                showToast("‚ñ∂Ô∏è Reanudado", "El juego contin√∫a", "success");
            }
        }

        function handleWindowResize() {
            if(gameState.gameStarted && !gameState.gameCompleted){
                const mazeEl = document.getElementById("mazeContainer");
                if(mazeEl && mazeEl.style.width) { // Solo re-renderizar si el juego est√° activo y el laberinto existe
                    renderGame();
                }
            }
        }
        
        function initializeApp() {
            console.log("üöÄ Inicializando aplicaci√≥n");
            if(globalPauseBtn){
                globalPauseBtn.addEventListener("click", togglePause);
                globalPauseBtn.disabled = true; // Deshabilitado hasta que el juego comience
            }
            if(globalResetBtn){
                globalResetBtn.addEventListener("click", resetGame);
            }

            let resizeTimeout;
            window.addEventListener("resize", () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(handleWindowResize, 250);
            });

            // Manejo de toques para m√≥viles
            if(isMobile){
                document.addEventListener('touchstart', e => {
                    if(e.touches.length > 1 && gameState.gameStarted) e.preventDefault(); // Prevenir zoom con m√∫ltiples dedos
                }, {passive: false});
                let lastTouchEnd = 0;
                document.addEventListener('touchend', e => {
                    if(gameState.gameStarted){ // Solo si el juego ha comenzado
                        const now = (new Date()).getTime();
                        if (now - lastTouchEnd <= 300) { // Prevenir zoom por doble toque r√°pido
                            e.preventDefault();
                        }
                        lastTouchEnd = now;
                    }
                }, false);
            }
            
            // Pausar si la pesta√±a se oculta
            document.addEventListener('visibilitychange', () => {
                if(document.hidden && gameState.gameStarted && !gameState.paused && !gameState.gameCompleted){
                    togglePause();
                }
            });

            renderApp();
            console.log("‚úÖ Aplicaci√≥n inicializada");
        }

        function detectDeviceCapabilities() {
            const hasVibration = 'vibrate' in navigator;
            const isLandscape = window.innerWidth > window.innerHeight;
            // Considerar un dispositivo de alto rendimiento si no es m√≥vil, tiene buena densidad de p√≠xeles y resoluci√≥n
            const hasHighPerf = window.devicePixelRatio <= 2 && window.innerWidth <= 1920 && !isMobile; 
            
            if(isMobile && !isLandscape && gameState.gameStarted){ // Solo mostrar si el juego ya empez√≥
                showToast("üì± Sugerencia", "Para mejor experiencia, usa orientaci√≥n horizontal.");
            }
            console.log(`üì± Dispositivo: Mobile=${isMobile}, Landscape=${isLandscape}, HighPerf=${hasHighPerf}, Vibration=${hasVibration}`);
        }

        // Funciones de depuraci√≥n (opcionales, pero √∫tiles)
        function getGameStatistics() {
            return {
                level: gameState.level,
                score: gameState.score,
                lives: gameState.lives,
                questionsAnswered: gameState.questionsAnswered,
                correctAnswers: gameState.correctAnswers,
                accuracy: gameState.questionsAnswered > 0 ? (gameState.correctAnswers / gameState.questionsAnswered) * 100 : 0,
                completion: gameState.totalFruits > 0 ? (gameState.fruitCollected / gameState.totalFruits) * 100 : 0,
                finalGrade: gameState.finalGrade,
                gameCompleted: gameState.gameCompleted,
                timestamp: new Date().toISOString()
            };
        }

        function debugGameState() {
            console.group("üîç Estado del Juego - Debug");
            console.log("Estado:", { 
                level: gameState.level, 
                started: gameState.gameStarted, 
                completed: gameState.gameCompleted, 
                paused: gameState.paused 
            });
            console.log("Progreso:", { 
                score: gameState.score, 
                lives: gameState.lives, 
                fruitCollected: gameState.fruitCollected, 
                totalFruits: gameState.totalFruits,
                questionsAnswered: gameState.questionsAnswered,
                correctAnswers: gameState.correctAnswers,
                totalQuestionsInLevel: gameState.totalQuestionsInLevel
            });
            console.log("Posiciones:", { 
                player: gameState.playerPosition, 
                ghosts: gameState.ghosts.map(g => ({id: g.id, pos: g.position, vulnerable: g.vulnerable}))
            });
            console.log("Preguntas:", {
                current: gameState.currentQuestion,
                poolSize: Array.isArray(gameState.questionPool) ? gameState.questionPool.length : 0,
                usedCount: gameState.usedQuestions.length
            });
            console.log("Audio:", {
                soundManagerInitialized: soundManager.isInitialized,
                audioContextState: Tone.context.state,
                soundsLoaded: Object.keys(soundManager.sounds).length > 0
            });
            console.groupEnd();
        }
        // Exponer funciones de debug al scope global si se desea
        if(typeof window !== 'undefined'){
            window.debugPhysicsGame = debugGameState;
            window.gameStats = getGameStatistics;
        }
        
        // Inicializar la aplicaci√≥n cuando el DOM est√© listo
        if(document.readyState === 'loading'){
            document.addEventListener('DOMContentLoaded', () => {
                detectDeviceCapabilities();
                initializeApp();
            });
        } else {
            detectDeviceCapabilities();
            initializeApp();
        }
        
        console.log("üî¨ Laberinto de F√≠sica v3 - C√≥digo cargado y listo.");
        setTimeout(() => {
            if (!gameState.gameStarted) { // Solo mostrar si el juego no ha comenzado (est√° en selector de nivel)
                 showToast("üî¨ ¬°Bienvenido al Laberinto de F√≠sica!", "Selecciona un nivel y presiona 'Comenzar' para iniciar la aventura del conocimiento. ¬°Recuerda que el audio se activar√° con tu primera interacci√≥n!", "success");
            }
        }, 1000);

    </script>
</body>
</html>
